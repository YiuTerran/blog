<!DOCTYPE html>
<html lang='zh' dir='ltr' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Gb28181解析 | 应许之地</title>

<meta name="generator" content="Hugo Eureka 0.9.0" />
<link rel="stylesheet" href="https://yiuterran.github.io/blog/css/eureka.min.css">
<script defer src="https://yiuterran.github.io/blog/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png">

<meta name="description"
  content="国标GB28181（以下简称国标）文档分析的文档我去年其实写过一版，但是由于原来的电脑炸了，文档还没来得及传上去就丢了（痛苦），所以还要重写一版做笔记">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"https://yiuterran.github.io/blog/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Gb28181解析",
      "item":"https://yiuterran.github.io/blog/posts/gb28181%E8%A7%A3%E6%9E%90/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://yiuterran.github.io/blog/posts/gb28181%E8%A7%A3%E6%9E%90/"
    },
    "headline": "Gb28181解析 | 应许之地","datePublished": "2022-03-02T09:46:50+08:00",
    "dateModified": "2022-03-02T09:46:50+08:00",
    "wordCount":  6545 ,
    "author": {
        "@type": "Person",
        "name": ["tryao"]
    },
    "publisher": {
        "@type": "Person",
        "name": "C. Wang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://yiuterran.github.io/blog/images/icon.png"
        }
        },
    "description": "国标GB28181（以下简称国标）文档分析的文档我去年其实写过一版，但是由于原来的电脑炸了，文档还没来得及传上去就丢了（痛苦），所以还要重写一版做笔记"
}
</script><meta property="og:title" content="Gb28181解析 | 应许之地" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://yiuterran.github.io/blog/images/icon.png">


<meta property="og:url" content="https://yiuterran.github.io/blog/posts/gb28181%E8%A7%A3%E6%9E%90/" />




<meta property="og:description" content="国标GB28181（以下简称国标）文档分析的文档我去年其实写过一版，但是由于原来的电脑炸了，文档还没来得及传上去就丢了（痛苦），所以还要重写一版做笔记" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="应许之地" />






<meta property="article:published_time" content="2022-03-02T09:46:50&#43;08:00" />


<meta property="article:modified_time" content="2022-03-02T09:46:50&#43;08:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="gb28181" />

<meta property="article:tag" content="multimedia" />





<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 ps-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="https://yiuterran.github.io/blog/" class="me-6 text-primary-text text-xl font-bold">应许之地</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="https://yiuterran.github.io/blog/authors/tryao/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">作者</a>
            <a href="https://yiuterran.github.io/blog/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">Light</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="grow pt-16">
    <div class="ps-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">Gb28181解析</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="me-6 my-2">
        <i class="fas fa-calendar me-1"></i>
        <span>2022-03-02</span>
    </div>
    <div class="me-6 my-2">
        <i class="fas fa-clock me-1"></i>
        <span>14 min read</span>
    </div>
    
    
    <div class="me-6 my-2">
        <i class="fas fa-folder me-1"></i>
        
        <a href="https://yiuterran.github.io/blog/categories/work/" class="hover:text-eureka">work</a>
        
    </div>
    

    
</div>
        
        
        

        <div class="content">
            <p>国标GB28181（以下简称国标）文档分析的文档我去年其实写过一版，但是由于原来的电脑炸了，文档还没来得及传上去就丢了（痛苦），所以还要重写一版做笔记。</p>
<p>国标目前有两个版本，2011和2016，以下以16版为准。16版本相比11版本，主要是增加了TCP的支持，11版是全部基于UDP传输的。</p>
<h2 id="协议结构">协议结构</h2>
<p><img src="https://s2.loli.net/2022/03/02/RX9NDzw4jgFWdoq.png" alt="截屏2022-03-02 上午10.44.52"></p>
<p>上图是直接从文档中截取的通信协议结构图。国标基于TCP/IP网络，主要分为两个传输通道，即一般会话通道和流媒体传输通道。前者基于SIP协议（图中<code>MANSCDP</code>和<code>MANSRTSP</code>是国标自行扩展的协议，仍然是基于SIP协议的），传输载体是SDP格式字符串；后者基于RTP/RTCP协议，传输载体主要是PS视频流和AAC等格式的音频数据。</p>
<h2 id="sip协议">SIP协议</h2>
<p>SIP协议初衷就是用于音视频通话，VOIP等技术大量用到该协议。</p>
<p>RFC3261规定了SIP协议的基础内容，包括<code>Register</code>, <code>Invite</code>等一系列注册和通信机制。SIP协议的通信方式类似HTTP，是典型的请求-响应。</p>
<h3 id="dialog-model">Dialog Model</h3>
<p><img src="https://s2.loli.net/2022/03/02/uSMXi4NVkYdC1Hn.png" alt=" SIP协议Session Model"></p>
<p>主叫方A呼叫被叫方B：</p>
<ul>
<li>步骤1：<code>主叫方A</code>发送<code>INVITE</code>请求到<code>代理服务器</code>；</li>
<li>步骤2：<code>代理服务器</code>发送100 Trying 响应<code>主叫方A</code>；</li>
<li>步骤3~6：<code>代理服务器</code>搜索<code>被叫方B</code>的地址，获取地址后转发INVITE请求；</li>
<li>步骤7~9：<code>被叫方B</code>生成的180 振铃响应，返回给<code>主叫方A</code>；</li>
<li>步骤10~12：<code>被叫方B</code>生成的200 OK响应，返回给<code>主叫方A</code>；</li>
<li>步骤13~17：<code>主叫方A</code>收到<code>被叫方B</code>200 OK响应后，向<code>被叫方B</code>发送一个ACK，会话建立；</li>
<li>步骤18~20：会话结束后，任何参与者（A或B）都可以发送一个BYE请求来终止会话；</li>
<li>步骤21~23：<code>主叫方A</code>发送200 OK响应来确认BYE，会话终止。</li>
</ul>
<p>以上的整个流程称之为一个<code>Dialog</code>，这个流程被称为<code>Session Model</code>通话模式。消息体负载大于1300字节时，一般采用该种通信模式。这也是RFC3261最初规定的一种通信方式。</p>
<h3 id="pager-model">Pager Model</h3>
<p>另外一种通信模式被称为<code>Pager Model</code>，适用于小流量通信。<strong>RFC3428</strong>扩展了SIP协议，增加了<code>MESSAGE</code>方法，类似UDP的设计思路，直接构造一条消息发过去即可（格式一般是SDP或者CPIM）。</p>
<p><img src="https://s2.loli.net/2022/03/02/meZKJFOcr7MYw4T.png" alt="Pager Model"></p>
<ul>
<li>步骤1：<code>User1</code>发送<code>MESSAGE</code>请求到<code>代理服务器</code>；</li>
<li>步骤2：<code>代理服务器</code>转发<code>User1</code>的MESSAGE请求给<code>USER2</code>；</li>
<li>步骤3：<code>User2</code>收到<code>User1</code>的消息后，回复200 OK给<code>代理服务器</code>；</li>
<li>步骤7~9：<code>代理服务器</code>转发200 OK回复给<code>User1</code></li>
</ul>
<p>显然这个流程比较简单。</p>
<h3 id="消息体格式">消息体格式</h3>
<p>类似HTTP，SIP消息分为三个部分：</p>
<ul>
<li>请求行(request-line) or 状态行(status-line)</li>
<li>消息头(header)</li>
<li>正文(body)</li>
</ul>
<h4 id="请求行">请求行</h4>
<p><strong>请求行格式：</strong><code>Method Request-URI SIP-Version CRLF</code>
<strong>请求行举例：</strong><code>INVITE sip:bob@zte.com SIP/2.0 /r/n</code></p>
<p>Method分为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Method</th>
<th style="text-align:left">方法说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">REGISTER</td>
<td style="text-align:left">注册联系信息</td>
</tr>
<tr>
<td style="text-align:left">INVITE</td>
<td style="text-align:left">发起会话请求</td>
</tr>
<tr>
<td style="text-align:left">ACK</td>
<td style="text-align:left">INVITE 请求的响应的确认</td>
</tr>
<tr>
<td style="text-align:left">CANCEL</td>
<td style="text-align:left">取消请求</td>
</tr>
<tr>
<td style="text-align:left">BYE</td>
<td style="text-align:left">终结会话</td>
</tr>
<tr>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">查询服务器能力</td>
</tr>
<tr>
<td style="text-align:left">MESSAGE</td>
<td style="text-align:left">RFC3428，上文已有描述</td>
</tr>
</tbody>
</table>
<h4 id="状态行">状态行</h4>
<p><strong>状态行格式：</strong> <code>SIP-Version Status-Code Reason-Phrase CRLF</code>
<strong>状态行举例：</strong><code>SIP/2.0 200 OK /r/n</code></p>
<p>状态码的设计也和HTTP非常类似：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx:</td>
<td style="text-align:left">临时响应、表示请求消息正在被处理</td>
</tr>
<tr>
<td style="text-align:left">2xx</td>
<td style="text-align:left">成功响应、表示请求已被成功接收完全理解并接收</td>
</tr>
<tr>
<td style="text-align:left">3xx</td>
<td style="text-align:left">重定向响应、表示需采取进一步完成请求</td>
</tr>
<tr>
<td style="text-align:left">4xx</td>
<td style="text-align:left">客户机错误、表示请求消息中包含语法错误信息或服务器无法完成客户机的请求</td>
</tr>
<tr>
<td style="text-align:left">5xx</td>
<td style="text-align:left">服务器错误、表示服务器无法合法完成请求</td>
</tr>
<tr>
<td style="text-align:left">6xx</td>
<td style="text-align:left">全局故障 、表示任何服务器都无法完成该请求</td>
</tr>
</tbody>
</table>
<p>常用的状态码举例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">msg</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Trying</td>
<td style="text-align:left">试呼叫</td>
</tr>
<tr>
<td style="text-align:left">180</td>
<td style="text-align:left">Ringing</td>
<td style="text-align:left">振铃</td>
</tr>
<tr>
<td style="text-align:left">181</td>
<td style="text-align:left">Call is Being Forwarded</td>
<td style="text-align:left">呼叫正在前转</td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">成功响应</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Moved Temporarily</td>
<td style="text-align:left">临时迁移</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">错误请求</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">未授权</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">禁止</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">用户不存在</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Timeout</td>
<td style="text-align:left">请求超时</td>
</tr>
<tr>
<td style="text-align:left">480</td>
<td style="text-align:left">Temporarily Unavailable</td>
<td style="text-align:left">暂时无人接听</td>
</tr>
<tr>
<td style="text-align:left">486</td>
<td style="text-align:left">Busy Here</td>
<td style="text-align:left">线路忙</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Server Time-out</td>
<td style="text-align:left">服务器超时</td>
</tr>
<tr>
<td style="text-align:left">600</td>
<td style="text-align:left">Busy Everywhere</td>
<td style="text-align:left">全忙</td>
</tr>
</tbody>
</table>
<p>可以说和HTTP的状态码含义非常接近。</p>
<p>中间响应消息1xx的使用则是为了节省网络开销设计的，一旦 UC 收到任何一个中间响应消息，则UC必须<strong>停止消息重发定时器</strong>，不再从发这个请求消息，反之则直到收到最终响应消息或重发定时器超时。</p>
<h4 id="header">Header</h4>
<p>格式和HTTP的header也保持一致，典型的<code>k:v</code>结构。常用header包括：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Header</th>
<th style="text-align:left">含义说明</th>
<th style="text-align:left">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Call-ID</td>
<td style="text-align:left">由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变。</td>
<td style="text-align:left">Call-ID: <a href="mailto:asd88asd77a@1.2.3.4">asd88asd77a@1.2.3.4</a></td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">表示请求的发起者</td>
<td style="text-align:left">From: sip:user1@domain.com;tag=49583</td>
</tr>
<tr>
<td style="text-align:left">To</td>
<td style="text-align:left">表示请求的接收者</td>
<td style="text-align:left">To: sip:user2@domain.com</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路</td>
<td style="text-align:left">Via: SIP/2.0/TCP user1pc.domain.com;branch=z9hG4bK776sgdkse</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">用于表示这个包最多可以传送多少跳，每经过一跳都会减一，当Max-Forwards==0系统会返回483。默认为70</td>
<td style="text-align:left">Max-Forwards: 70</td>
</tr>
<tr>
<td style="text-align:left">Contact</td>
<td style="text-align:left">包含源的URI信息，用来给响应方直接和源建立连接用</td>
<td style="text-align:left">Contact: sip:192.168.100.1:1111</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">指明消息体的类型</td>
<td style="text-align:left">Content-Type: text/plain；Content-Type: application/sdp; Content-Type: application/cpim;</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">指明消息体的字节大小</td>
<td style="text-align:left">Content-Length: 18</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">鉴权凭证消息</td>
<td style="text-align:left">Authorization: Digest username=&ldquo;01062237493&rdquo;, realm=&ldquo;192.168.2.89&rdquo;, qop=auth, algorithm=MD5, uri=&ldquo;sip:192.168.2.89&rdquo;, nonce=&ldquo;e17d377c3d2d9c343e26576a7fd04738481dfc10&rdquo;, nc=00000001, cnonce=&ldquo;12660455546344082314666316435946&rdquo;, response=&ldquo;f57e47ce03162293b9ced07362ce2b79&rdquo;</td>
</tr>
</tbody>
</table>
<p>对于Dialog，From tag, To tag, Call id三者，就形成了本次会话的唯一ID，既dailog id.</p>
<p>在SIP消息最初发出的时候，发送端(UAC)会在<code>From</code>后面生成tag，但是To后面没有。消息接收端(UAS)会在回复的时候在<code>To</code>后面加上tag。</p>
<p><code>CSeq</code>头用于保证消息的顺序性，在同一个Dialog中标识及排序事务（transaction）以及区分新的请求与请求的重发。对于ACK而言，CSeq的序号必须与其所对应的request相同。对于CANCEL而言，CSeq的序号也必须与其cancel掉的request相同。否则，Dialog里面每个新的Request，Cseq+1。需要注意的是：在同一个对话中的UAC和UAS分别维护自己的CSeq序号，他们发出请求的CSeq序号是不相关的。</p>
<p>一次呼叫只能建立一个会话，但是可以建立多个dialog，因为呼叫可以是多个目标（会议），只是每个dialog的Request和Response的Call-ID必须一致。</p>
<p><code>Via</code>中的<code>branch</code>是一个事务的id，这个branch参数的值必须用<strong>z9hG4bK</strong>打头。其它部分是对“To, From, Call-ID头域和Request-URI”按一定的算法加密后得到。</p>
<h3 id="manscdp">MANSCDP</h3>
<p>在国标附录A里面有描述，主要是一系列对设备的查询、控制等指令，并规定了请求/应答的数据结构。</p>
<p>MANSCDP使用xml进行通信，作为SIP <code>MESSAGE</code>类型消息的负载，Content-Type为<code>Application/MANSCDP+xml</code>。</p>
<p>消息大致分为以下几类，名称就是xml的根标签。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Request</td>
<td>Control</td>
<td>控制设备指令</td>
</tr>
<tr>
<td>Request</td>
<td>Query</td>
<td>查询设备信息指令</td>
</tr>
<tr>
<td>Request</td>
<td>Notify</td>
<td>通知，主要用于设备向云端发送告警。</td>
</tr>
<tr>
<td>Response</td>
<td>Response</td>
<td>应答</td>
</tr>
</tbody>
</table>
<p>基础数据结构，写代码的话这些就是类或者alias：</p>
<p><img src="https://s2.loli.net/2022/03/02/jYEKN9mSeRAMzgL.png" alt="截屏2022-03-02 下午2.07.31"></p>
<p>再下面是定义的请求/应答格式，这里不再详述。</p>
<p>举个例子，设备远程启动，请求格式：</p>
<pre><code class="language-http">MESSAGE sip:34020000001320000001@3402000000 SIP/2.0
Call-ID: fac5d9915d7b4b64e46054bbbda3f29f@0.0.0.0
CSeq: 1 MESSAGE
From: &lt;sip:34020000002000000001@3402000000&gt;;tag=58726327_53173353_c2be9be1-4121-42af-b4e2-e4896ab42120
To: &lt;sip:34020000001320000001@3402000000&gt;
Max-Forwards: 70
Content-Type: Application/MANSCDP+xml
Route: &lt;sip:34020000001320000001@192.168.10.177:5061;line=9a1ca01668b5778;lr&gt;
Via: SIP/2.0/UDP 192.168.10.177:5060;branch=z9hG4bKc2be9be1-4121-42af-b4e2-e4896ab42120_53173353_18042259617961
Content-Length: 164
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;Control&gt;
&lt;CmdType&gt;DeviceControl&lt;/CmdType&gt;
&lt;SN&gt;17298&lt;/SN&gt;
&lt;DeviceID&gt;34020000001320000001&lt;/DeviceID&gt;
&lt;TeleBoot&gt;Boot&lt;/TeleBoot&gt;
&lt;/Control&gt;
</code></pre>
<p>应答是先给200，然后异步回应：</p>
<pre><code class="language-http">MESSAGE sip:34020000001320000001@192.168.10.177 SIP/2.0
Via: SIP/2.0/UDP 192.168.10.177:5061;rport=5061;branch=z9hG4bK3569164341;received=192.168.10.177
From: &lt;sip:192.168.10.177:5060&gt;;tag=3889968117
To: &lt;sip:34020000001320000001@192.168.10.177&gt;
Call-ID: 2825372510
CSeq: 20 MESSAGE
Content-Type: Application/MANSCDP+xml
Max-Forwards: 70
User-Agent: eXosip/3.6.0
Content-Length: 162
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;Response&gt;
&lt;CmdType&gt;DeviceControl&lt;/CmdType&gt;
&lt;SN&gt;17298&lt;/SN&gt;
&lt;DeviceID&gt;34020000001320000001&lt;/DeviceID&gt;
&lt;Result&gt;OK&lt;/Result&gt;
&lt;/Response&gt;
</code></pre>
<p>服务端收到响应之后仍然会回复一个200.</p>
<h3 id="mansrtsp">MANSRTSP</h3>
<p>类似的，国标扩展了SIP协议以支持媒体控制。MANSRTSP采用RTSP协议（RTC2326）规定的格式，所以算是缝合和SIP和RTSP。Method使用<code>INFO</code>，<code>Content-Type</code>设为<code> Application/MANSRTSP</code>.</p>
<p>示例格式：</p>
<blockquote>
<p>message=start-line
message header
CRLF
[message body]</p>
</blockquote>
<p>四个部分：起始行，消息头，分隔行，消息体。</p>
<h4 id="起始行">起始行</h4>
<p>包括请求和应答两种。</p>
<p>请求格式：<code>Method SP RTSP-Version CRLF</code>，Method包括：<strong>PLAY,PAUSE,TEARDOWN</strong>，这是RTSP中规定的控制子集，即播放、暂停和停止。</p>
<p>例：</p>
<pre><code class="language-http">PLAY MANSRTSP/1.0
CSeq:2
Range:npt=now-
</code></pre>
<p>头<code>Scale</code>表示倍速播放；<code>Pause Time</code>表示暂停位置（now表示当前位置）；随机拖放使用<code>Range</code>定位。</p>
<p>Scale至少支持： 0 .25 、0 .5 、1 、2 、4 ，Range表示播放录像起点的相对值,取值范围为0到播放录像的终点时间,参数以s为单位。</p>
<p>应答格式：<code>Status-Line = RTSP-Version SP Status-Code SP Reason-PhraseCRLF</code>.</p>
<p>例：<code>RTSP/1.0 200 OK</code></p>
<p>请求和应答的CSeq应该相等。</p>
<h2 id="rtp协议">RTP协议</h2>
<p>类似RTSP协议栈，国标的媒体传输通过RTP(RFC 3550)进行，并辅以RTCP控制(RFC 3550)。国标允许RTP传输基于PS封装的视音频数据或视音频基本流数据。即PS流或者H264/H265裸流。</p>
<p>需要注意的是2016版本的流封装里面还是没有H.265相关内容的，只有MPEG-4/H.264/SVAC这三种格式支持。</p>
<p>RTP的流媒体封装参考RTC即可，这里不再赘述。</p>
<h2 id="编码标准">编码标准</h2>
<p>国标对各类设备的编码做了统一规定，需要保证全局唯一性。一般设备的国标编码是留空的，需要使用者自己设计。</p>
<p>SIP的URI格式是<code>sip[s]:username@domain;uri-parameters</code>，名称一般就是国标编码，注意服务器一般也是使用国标编码命名的。RFC3261中对该格式进行详细规定。</p>
<p>domain一般就是ip+port，也可以使用域名，推荐端口是5060.</p>
<p><strong>特别注意</strong>：国标规定SIP信令字符集是GB2312，而不是UTF-8.</p>
<h2 id="通信流程">通信流程</h2>
<p>首先是设备注册(SIP register)，如果设备或系统注册不成功,宜延迟一定的随机时间后重新注册。设备注册完成后设备与服务端之间就会建立长连接。注册完毕后设备会自动与服务器进行NTP对时，后续操作即可由服务端主动发起。</p>
<p>注册完成后，服务端即可主动发起请求。主要包括：</p>
<ul>
<li>音视频实时点播（直播）</li>
<li>设备控制（PTZ、录像、报警设备的布防/撤防）</li>
<li>设备信息查询（包括设备ID、设备名、设备厂家名称、设备型号、设备地址、设备口令、设备类型、设备状态、设备安装地址、设备归属单位、父设备ID等信息）</li>
<li>历史音视频数据检索、回放、下载</li>
<li>语音广播、对讲</li>
</ul>
<p>设备主动报送的信息包括：</p>
<ul>
<li>告警信息</li>
<li>设备状态</li>
</ul>
<h3 id="注册注销">注册/注销</h3>
<p>设备注册/注销都要进行认证，支持口令和数字证书两种安全级别的认证。</p>
<p>在高安全级别下，使用sip+TLS进行加密传输。</p>
<p>SIP本身还要通过数字摘要做信令认证，算法如下：</p>
<blockquote>
<p>在SIP的header中增加Date字段和Note字段，Note= (Digestnonce=&quot;&quot;,algorithm = )，算法包括MD5、SHA-1、SHA-256等常见算法。nonce 的 值 为 algorithm [From + to + CallId + Date+seed+ 消息体 ]数字摘要经过BASE64编码后的值,algorithm 的值为数字摘要的算法名称,“+”为字符串连接运算。Date应在校时精度范围之内，精度为秒，偏离值一般不超过10分钟。</p>
</blockquote>
<p>具体的算法流程这里不再列出，就是常见的保证数据完整性的验证。</p>
<p>注册类似DHCP，是有时限的（默认1d，可以最短调到1h），到期之前需要设备自行重新注册。注册成功后设备就显示在线了。</p>
<p>基本注册（口令注册）流程如下：</p>
<ol>
<li>SIP代理向SIP服务器发送Register请求；</li>
<li>SIP服务器向SIP代理发送响应401,并在响应的消息头WWW_Authenticate字段中给出适合SIP代理的认证体制和参数；</li>
<li>SIP代理重新向SIP服务器发送Register请求,在请求的Authorization字段给出信任书,包含认证信息；</li>
<li>SIP服务器对请求进行验证,如果检查出SIP代理身份合法,向SIP代理发送成功响应200 OK,如果身份不合法则发送拒绝服务应答；</li>
</ol>
<p>基于数字证书的认证流程会复杂许多，这里不再详述。</p>
<p>注销和注册的流程其实类似，都用<code>Register</code>方法，只是Expires设为0.</p>
<h3 id="直播">直播</h3>
<p>服务端Invite之后，设备才开始推流，所以可以实现按需取流。</p>
<p>平台、设备媒体流保活机制规定如下:</p>
<ol>
<li>
<p>链路建立后,码流经过的各级平台应具备媒体流丢失监测能力,若监测到媒体流丢失,应释放该条媒体链路,并通过会话内Bye消息通知上下级平台;</p>
</li>
<li>
<p>上下级平台之间、平台与设备之间、平台与客户端之间应通过注册、状态信息报送等进行状态监测,若监测到媒体流接收方或媒体流发送方故障或离线,应主动释放媒体链路,停止媒体流的发送;</p>
</li>
<li>
<p>通过Subject标识进行已发送流的清理判断。</p>
<ul>
<li>
<p>上级平台向下级平台、平台向设备发送呼叫请求时,应携带Subject头域,Subject头域的“媒体流发送者ID:发送方媒体流序列号”用于对媒体源标识,此标识与请求的码流具有对应关系。</p>
</li>
<li>
<p>下级平台、设备在接收到呼叫请求后,应判断是否在发送以此媒体源标识的码流,若已经在发送,则应释放现有媒体流发送链路并按照请求建立新的媒体流发送链路。</p>
</li>
</ul>
</li>
</ol>
<p>点播流程可以由最终收流观看的客户端主动发起，也可以由SIP信令服务器自行发起。由于BS架构下，浏览器不支持RTP流直播，所以实际使用中。一般Invite请求是由SIP服务器发出，流推送到流媒体服务器之后，需要转协议才能给客户端进行观看。</p>
<h3 id="设备控制">设备控制</h3>
<p>参考上述<code>MANSCDP</code>部分，通过<code>MESSAGE</code>消息实现。</p>
<p>部分命令不需要应答操作结果，只回答一个200 OK表示已经收到。包括：</p>
<ul>
<li>相机、云台控制(PTZ)</li>
<li>远程启动</li>
<li>强制关键帧(IDR)</li>
<li>拉框放大/缩小</li>
</ul>
<p>部分命令需要有明确的Response，包括：</p>
<ul>
<li>录像控制</li>
<li>报警布防/撤防</li>
<li>报警复位</li>
<li>看守位控制</li>
<li>设备配置命令</li>
</ul>
<p>注意，无论何种命令，对端都要有一个应答表示已收到（因为通信可能基于UDP）</p>
<h3 id="报警事件">报警事件</h3>
<p>同样基于<code>MANSCDP</code>扩展协议。</p>
<p>按着标准规定，报警事件需要服务端进行处理结果响应。</p>
<h3 id="设备查询">设备查询</h3>
<p>标准提供了灵活的设备组织形式，允许按系统编码（级联时），行政区划，业务分组、虚拟组织等组织方式进行设备目录查询。设备目录查询的响应数据包括：命令类型(CmdType)、命令序列号(SN)、设备/区域/系统编码(De-viceID)、设备/区域/系统名称(Name)、设备状态(Status)、经度(Longitude)、纬度(Latitude)等。注意这里的SN不是设备序列号，而是命令序列号；用来异步映射请求和响应。</p>
<p>得到设备目录之后，可以对某个具体的设备进行消息查询。响应内容主要包括：命令类型(CmdType)、设备编码(DeviceID)、设备名称(DeviceName)、查询结果标志(Result)、厂商信息(Manufacturer)、设备型号(Model)、固件版本(Firm-ware)、最大支持摄像机个数(Channel)等。</p>
<p>设备状态可以单独进行查询，可以单独获取设备的状态标志位，包括：目标设备或区域或系统编码、命令类型(CmdType)、查询结果标志(Result)、是否在线(Online)、是否正常工作(Status)、不正常原因(Reason)、是否编码(Encode)、是否录像(Record)、设备时间和日期(DeviceTime)、报警设备状态列表(Alarmstatus)等,报警设备状态列表应包括报警设备或区域或系统编码(DeviceID)、报警设备状态(DutyStatus)等。</p>
<p>设备配置信息也可以单独查询，这里没有严格规定返回值内容。</p>
<p>设备预置位（云台）也可以单独查询，响应结果主要包括预置位编码(PresetID)、预置位名称(Pr-esetName)。</p>
<h3 id="状态报送">状态报送</h3>
<p>类似报警事件，如果设备（网关、SIP设备、SIP客户端或联网系统）的状态异常，需要立即向SIP监控域的SIP服务器发送状态信息。即使无异常，也需要定时上报，即状态心跳（默认时间60s）。连续心跳丢失（默认超过3次）之后认为设备离线。</p>
<h3 id="音视频文件检索">音视频文件检索</h3>
<p>即回放检索功能，其检索条件包括区域、设备、录像时间段、录像地点、录像内容等。</p>
<p>响应内容可以分页返回，为了保证可靠，需要进行串行发送。即收到上一条的ack再进行下一页返回，服务端可以批量进行ack。</p>
<h3 id="历史音视频回放">历史音视频回放</h3>
<p>类似直播，也是Invite发起。不同的是，必须支持快进、暂停功能，相关控制见<code>MANSRTSP</code>部分。</p>
<p>媒体播放完毕之后，发送端需要使用<code>MESSAGE</code>消息通知服务器发送已经结束。如果服务端主动不看了，需要发送BYE通知设备端停止推流。</p>
<h3 id="媒体下载">媒体下载</h3>
<p>该功能类似回放，但是需要响应端给出文件大小相关参数方便计算下载进度。如果无法计算出大小，则需要根据码流中的时间来计算。</p>
<p>下载可以指定倍速，下载一旦开始就不能修改速度等参数，也不能暂停。</p>
<h3 id="对时">对时</h3>
<p>如上所述，对时是在注册的时候完成的。为了避免时钟偏移，注册过期时间不宜过长。</p>
<h3 id="订阅和发布">订阅和发布</h3>
<p>事件订阅包括报警事件、移动设备位置通知事件等。</p>
<p>设备目录订阅（对NVR）可以及时获取设备变更通知。</p>
<h3 id="语音广播和语音对讲">语音广播和语音对讲</h3>
<p>这里假设终端设备（如IPC）具有语音广播能力，则可以利用gb协议进行双向语音广播。</p>

        </div>
        
        <div class="my-4">
    
    <a href="https://yiuterran.github.io/blog/tags/gb28181/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#gb28181</a>
    
    <a href="https://yiuterran.github.io/blog/tags/multimedia/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#multimedia</a>
    
</div>
        
        
        


        
        
        <div class="py-2">
    
    <div class="flex flex-col md:flex-row items-center my-8">
        <a href="https://yiuterran.github.io/blog/authors/tryao/" class="w-24 h-24 md:me-4">
            
            
            <img src="https://yiuterran.github.io/blog/images/icon.png" class="w-full bg-primary-bg rounded-full" alt="Avatar">
            
        </a>
        <div class="w-full md:w-auto mt-4 md:mt-0">
            <a href="https://yiuterran.github.io/blog/authors/tryao/" class="block font-bold text-lg pb-1 mb-2 border-b">个人介绍</a>
            <span class="block pb-2">兴趣使然的程序员，博而不精，乐学不倦</span>
            
            
            
            
            
            <a href="mailto:yaotairan@gmail.com" class="me-1">
                <i class="fas fa-envelope"></i>
            </a>
            
            
            
            
            
            <a href="https://twitter.com/TerranYiu" class="me-1">
                <i class="fab fa-twitter"></i>
            </a>
            
            
            
            
            
            <a href="https://github.com/YiuTerran" class="me-1">
                <i class="fab fa-github"></i>
            </a>
            
        </div>
    </div>
    
</div>
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">Next</span>
        <a href="https://yiuterran.github.io/blog/posts/first-post/" class="block">重新启程</a>
        
    </div>
</div>

        



    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">On This Page</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#协议结构">协议结构</a></li>
    <li><a href="#sip协议">SIP协议</a>
      <ul>
        <li><a href="#dialog-model">Dialog Model</a></li>
        <li><a href="#pager-model">Pager Model</a></li>
        <li><a href="#消息体格式">消息体格式</a>
          <ul>
            <li><a href="#请求行">请求行</a></li>
            <li><a href="#状态行">状态行</a></li>
            <li><a href="#header">Header</a></li>
          </ul>
        </li>
        <li><a href="#manscdp">MANSCDP</a></li>
        <li><a href="#mansrtsp">MANSRTSP</a>
          <ul>
            <li><a href="#起始行">起始行</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#rtp协议">RTP协议</a></li>
    <li><a href="#编码标准">编码标准</a></li>
    <li><a href="#通信流程">通信流程</a>
      <ul>
        <li><a href="#注册注销">注册/注销</a></li>
        <li><a href="#直播">直播</a></li>
        <li><a href="#设备控制">设备控制</a></li>
        <li><a href="#报警事件">报警事件</a></li>
        <li><a href="#设备查询">设备查询</a></li>
        <li><a href="#状态报送">状态报送</a></li>
        <li><a href="#音视频文件检索">音视频文件检索</a></li>
        <li><a href="#历史音视频回放">历史音视频回放</a></li>
        <li><a href="#媒体下载">媒体下载</a></li>
        <li><a href="#对时">对时</a></li>
        <li><a href="#订阅和发布">订阅和发布</a></li>
        <li><a href="#语音广播和语音对讲">语音广播和语音对讲</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="ps-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://www.wangchucheng.com/">WANG Chucheng</a> and <a href="https://www.ruiqima.com/">MA Ruiqi</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>