<!DOCTYPE html>
<html
  lang="zh"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Kotlin要点笔记 | 应许之地</title>

<meta name="generator" content="Hugo Eureka 0.9.3" />
<link rel="stylesheet" href="https://yiuterran.github.io/blog/css/eureka.min.30cfa2a7d2b5754cd246875caad26d69af1d8567ea53339f6729fe1d0ceee8917d33fcd191d4284da2a5da6359d79cb7.css">
<script defer src="https://yiuterran.github.io/blog/js/eureka.min.e8043b71b627e3cfd9b2a5de56adf007f5af83dee672ca0c186aa2e29a10d6f648632064d0c00b2fa4d1b11e0f196af3.js"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="https://yiuterran.github.io/blog/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" media="print" onload="this.media='all';this.onload=null">


<script defer type="text/javascript" src="https://yiuterran.github.io/blog/js/fontawesome.min.a975d08212c5439f29e6074e7ad58e159ae1ef5efb6a31962fa3b6885557e794dd9315f4a8a16d705066d023f4eaaf07.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C0R8DENDJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'G-C0R8DENDJ0');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png">

<meta name="description"
  content="实际上学习kotlin的动力一直不足，因为java is enough. 不过最近打算写一个QQ机器人玩，现在流行的框架是基于kotlin的，虽然可以用HTTP API进行">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章列表",
      "item":"https://yiuterran.github.io/blog/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Kotlin要点笔记",
      "item":"https://yiuterran.github.io/blog/posts/kotlin%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://yiuterran.github.io/blog/posts/kotlin%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/"
    },
    "headline": "Kotlin要点笔记 | 应许之地","datePublished": "2023-03-05T12:58:37+08:00",
    "dateModified": "2023-03-05T12:58:37+08:00",
    "wordCount":  5304 ,
    "author": {
        "@type": "Person",
        "name": ["tryao"]
    },
    "publisher": {
        "@type": "Person",
        "name": "C. Wang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://yiuterran.github.io/blog/images/icon.png"
        }
        },
    "description": "实际上学习kotlin的动力一直不足，因为java is enough. 不过最近打算写一个QQ机器人玩，现在流行的框架是基于kotlin的，虽然可以用HTTP API进行"
}
</script><meta property="og:title" content="Kotlin要点笔记 | 应许之地" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://yiuterran.github.io/blog/images/icon.png">


<meta property="og:url" content="https://yiuterran.github.io/blog/posts/kotlin%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/" />




<meta property="og:description" content="实际上学习kotlin的动力一直不足，因为java is enough. 不过最近打算写一个QQ机器人玩，现在流行的框架是基于kotlin的，虽然可以用HTTP API进行" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="应许之地" />






<meta property="article:published_time" content="2023-03-05T12:58:37&#43;08:00" />


<meta property="article:modified_time" content="2023-03-05T12:58:37&#43;08:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="kotlin" />






  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="https://yiuterran.github.io/blog/" class="me-6 text-primary-text text-xl font-bold">应许之地</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="https://yiuterran.github.io/blog/authors/tryao/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">作者</a>
            <a href="https://yiuterran.github.io/blog/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">Kotlin要点笔记</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2023-03-05</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>11分钟阅读时长</span>
  </div>

  

  
</div>


  
  

  <p>实际上学习kotlin的动力一直不足，因为java is enough. 不过最近打算写一个QQ机器人玩，现在流行的框架是基于kotlin的，虽然可以用HTTP API进行桥接，但是这样部署太麻烦，而且性能有影响，索性简单的学习一下kotlin，然后直接扩展。用的教材是阿里的《kotlin核心编程》。</p>
<h2 id="语法要点">语法要点</h2>
<ol>
<li>var声明变量，val声明常量（即java里面的final，注意不是immutable），格式类似golang，除了类型前面要加冒号；</li>
<li>val声明的变量可以不立即赋值；</li>
<li>支持通过<code>fun</code>定义函数，也支持函数闭包，格式也类似golang，不过返回类型之前要加<code>:</code>；</li>
<li>类似C++，函数支持默认参数；</li>
<li>函数类型声明的格式和函数不一样，返回类型之前要用<code>-&gt;</code>；特别的，没有返回值也要写<code>-&gt;Unit</code></li>
<li>返回值同样可以是函数，所以这个格式有点像haskell，如<code>(Int) -&gt;((Int)-&gt;Unit)</code>，可以简化为<code>(Int)-&gt;(Int)-&gt;Unit</code>，这样就更像Haskell了；</li>
<li>通过<code>class::func_memeber_name</code>来引用函数或者成员变量；</li>
<li>lambda表达式的格式非常类似函数声明：<code>func f (x:Int,y:Int)-&gt;Int={x,y-&gt;x+y}</code>，或者更简单点<code>val f ={x:Int,y:Int: x+y}</code>；即用<code>{}</code>括起来的表达式；</li>
<li>单个参数可以不声明，隐式的为<code>it</code>；</li>
<li>func与lambda的区别：</li>
<li>fun在没有等号，只有花括号时，就是最常见的函数实现，必须带return；</li>
<li>fun有等号，没有花括号时，表示单表达式函数体，此时无须带return；</li>
<li>如果是等号同时有花括号，无论使用val还是fun，都表示lambda表达式；</li>
<li>lambda可以定义接收者，语法是<code>val sum: Int.(int) -&gt; Int = {other-&gt;plus(other)}</code>;</li>
<li>kotlin的闭包是可以修改外部变量的，比java合理；</li>
<li>如果一个函数只有一个参数，且参数是函数，则调用该函数时，无须传入外层的括号：</li>
</ol>
<pre><code class="language-kotlin">func t(block: ()-&gt;Unit){
    block()
}
t{
    println(&quot;hello world&quot;)
}
</code></pre>
<ol start="11">
<li>如果一个函数有多个参数，最后一个参数是函数时，也可以省略最后一个参数直接传入内容，如：</li>
</ol>
<pre><code class="language-kotlin">func t(s:String, block:(String)-&gt;Unit){
    block(s)
}
t(&quot;hello world&quot;){
    s-&gt;println(s)
}
</code></pre>
<ol start="12">
<li>与C++类似，kotlin中很多流程控制语句是一个表达式，即会返回值，所以他可以用类似Python的方式实现3目运算：<code>val t = if(x&gt;3) 5 else 7</code>；</li>
<li>kotlin设计<code>Unit</code>代替<code>void</code>，就是为了让所有函数调用都有返回值（即成为表达式）；</li>
<li>枚举是类，语法有点像C++11：<code>enum class Day{}</code>; 如果要加方法的话，最后一个枚举要加一个<code>;</code></li>
<li>kotlin支持模式匹配，语法有点像rust，关键词是<code>when</code>，当然它也是一个表达式：</li>
</ol>
<pre><code class="language-kotlin">val k = when(day){
    Day.MON -&gt; 1
    Day.THU -&gt; 2
    else -&gt; 3
}
</code></pre>
<ol start="16">
<li>内置range表达式，类似rust，如<code>for (k in 1..10 step 2)</code>，倒着用<code>10 downTo 1 step -2</code>；全闭区间；</li>
<li>如果想用左闭右开区间，用<code>1 until 10</code>；</li>
<li>数组遍历，如果想带上下标，用<code>array.withIndex()</code>，类似Python的<code>enumerate</code>；</li>
<li>支持中缀函数，类似Haskell，形式是<code>infix func</code>。声明条件比较苛刻：
<ol>
<li>必须是成员函数或者扩展函数，这样函数左侧的对象是确定的</li>
<li>只能有一个参数，即函数右侧的参数</li>
<li>该参数不能有默认值</li>
</ol>
</li>
<li>kotlin的可变参数用<code>vararg</code>来表示，比较特别的是，它不需要一定是最后一个参数；有点像Python的<code>(*args, **kwargs)</code>；</li>
<li>kotlin的字符串支持下标访问；支持三引号（类似Python）；支持字符串模板（类似bash）；</li>
<li>支持<code>==</code>判断结构相等（相当于java里面的<code>equal</code>)，<code>===</code>判断引用相等(相当于java的<code>==</code>)；</li>
<li>kotlin支持内联函数，但是设计的很复杂，一般情况下尽量不要使用，除了泛型注入类型；</li>
<li>inline可以让lambda表达式非局部返回，即直接return父函数的结果；语法糖是<code>return @func</code></li>
</ol>
<h2 id="面向对象">面向对象</h2>
<p>上面可以看出kotlin实际上是支持函数式编程的，所以不是纯OO语言，但是也支持类。</p>
<ol>
<li>默认函数是public的，但是默认成员是private的；</li>
<li>所有变量必须显式初始化；</li>
<li>接口中的属性不能直接复制，需要写成<code>val c get()=100</code>而不是<code>val c =100</code>；</li>
<li>声明对象无须<code>new</code>，类似Python；</li>
<li>可以使用<code>init</code>函数块来进行初始化，属于构造函数的一部分，而且可以有多个；</li>
<li>构造函数可以放在类名后面声明：</li>
</ol>
<pre><code class="language-kotlin">class Bird(weight: Double, age: Int, color: String=&quot;blue&quot;){
    val weight = weight
    val age = age
    val color: String
    init{
        this.color = color
    }
}
</code></pre>
<ol start="7">
<li>延迟初始化：不可变成员的初始化延迟到对象被创建出来之后，如：</li>
</ol>
<pre><code class="language-kotlin">val color: String by lazy{
    if(age &gt; 10) &quot;blue&quot; else &quot;green&quot;
}
</code></pre>
<p>默认线程安全，仅能用来初始化不可变变量；第一次被调用时，才会被初始化。</p>
<ol start="8">
<li>对于var变量，可以用lateinit来延迟初始化，但是不能用于基础数据类，只能用包装类：</li>
</ol>
<pre><code class="language-kotlin">lateinit var color: String
</code></pre>
<ol start="9">
<li>可以通过<code>constructor</code>显式声明构造方法，这被称为<strong>从构造方法</strong>，主构造方法就是类名后面那个，语法类似C++的初始化列表：</li>
</ol>
<pre><code class="language-kotlin">constructor(other: Some)this(some.color){
    //...
}
</code></pre>
<ol start="10">
<li>继承的语法类似C++而不是java，用<code>:</code>，默认类并不能被继承，需要加上<code>open</code>关键字；</li>
<li>kotlin的protect不能被package访问，而是使用关键字<code>internal</code>；</li>
<li><code>sealed</code>表示密封类，它其实是枚举的一种扩展：当值为有限情况时，主要用于状态匹配；</li>
<li>kotlin一个文件里可以定义多个类，如果用private修饰类，表示类的作用域就是当前文件；</li>
<li>指定某个具体的父类：<code>super&lt;Base&gt;.func()</code>；</li>
<li>kotlin的接口可以定义成员，覆盖的时候同样要带上<code>overrite</code>；</li>
<li>如果要在kotlin中声明一个内部类，必须加上<code>inner</code>修饰符。这和java的设计是相反的：java需要加上static关键字才是嵌套类，默认就是内部类；</li>
<li>内部类可以访问外部类的成员，嵌套类则是完全独立的；可以用内部类解决多重继承问题；</li>
<li>类似C#，kotlin支持委托，语法上就是上面提到的<code>by</code>：</li>
</ol>
<pre><code class="language-kotlin">class Bird(flyer: Flyer, animal: Animal): CanFly by flyer, CanEat by animal{}
</code></pre>
<p>其实有点像组合，或者Go里面的结构体嵌套；</p>
<ol start="18">
<li>kotlin支持数据类，类似lombok中的<code>@Data</code>注解，语法是<code>data class</code>，java后续版本中有<code>record</code>关键字；</li>
<li>kotlin支持自动解包，类似<code>val(a,b,c)=o1</code>；数组、数据类都支持自动解包；</li>
<li>内置<code>Pair</code>和<code>Triple</code>；</li>
<li>移除了<code>static</code>关键字，但是引入了<code>object</code>关键字；</li>
<li>引入<strong>伴生对象</strong>概念，就是属于类的对象，使用<code>companion object</code>+花括号声明，类似java中的所有static变量+static初始化；</li>
<li>使用object可以直接声明单例；</li>
<li>类似Haskell，kotlin引入了ADT的概念，这主要通过<code>sealed class</code>实现，配合模式匹配和解构来使用；</li>
<li>kotlin的when可以嵌套；</li>
<li>kotlin的类型默认都是非空的，需要加上<code>?</code>来表示可为null，如<code>var k: String?</code>；</li>
<li>使用这些变量时，也可以在后面加上<code>?</code>表示非空判定（类似java里面的Optional，Swift和Rust里面有类似的设计）；默认值使用<code>?:</code>来赋予（可以使用表达式）；</li>
<li>非空断言：<code>!!</code>，断言失败抛出NPE异常；</li>
<li>使用<code>is</code>和<code>as</code>来做类型判断和转换，这个语法和Rust也很类似；</li>
<li>可以用<code>as?</code>来尝试转换，失败则返回null；</li>
<li>所有类型的父类是<code>Any</code>；java中所有的对象转到kotlin都被视为<strong>平台类型</strong>，即不知道是否非空的；</li>
<li><code>Nothing</code>是没有实例的类型，位于最底层，实际上只能为null；</li>
<li>可以对类的<strong>实例</strong>进行方法扩展，语法是：</li>
</ol>
<pre><code class="language-kotlin">fun ClassA.toJson():String{
    
}
</code></pre>
<p>扩展本质上注入静态方法；</p>
<ol start="34">
<li>kotlin支持运算符重载，函数名有点像Python，语法：</li>
</ol>
<pre><code class="language-kotlin">operator func ClassA.plus(rhs:ClassA):classA{
    
}
</code></pre>
<ol start="35">
<li>同名的情况下，扩展方法的优先级低于类成员；</li>
<li>当在扩展函数里调用this时，指代的是接收者类型的实例；如果想要强行指定类的实例，使用<code>this@ClassA</code>的语法；</li>
<li>扩展函数始终是静态调度，不支持多态（因为是静态实现）；</li>
<li>标准库中有<code>with</code>, <code>apply</code>, <code>run</code>, <code>let</code>, <code>takeIf</code>等扩展函数；其中<code>let</code>一般用于非空判断的执行逻辑；</li>
<li>不要滥用扩展功能；</li>
</ol>
<h2 id="数据结构">数据结构</h2>
<ol>
<li>不含有内置数组，直接用<code>Array</code>类，使用<code>arrayOf&lt;&gt;</code>来生成；建议优先使用<code>intArrayOf</code>之类的特化，性能更好；</li>
<li>一般的集合和java中一样，只是分为可变和不可变两种了；默认是<strong>不可变</strong>的，<code>Mutable</code>前缀的才是可变的；</li>
<li><code>mapOf(1 to 2)</code>，这里的to分割键值对；</li>
<li>直接使用函数式接口处理数据会创建很多临时数据结构（因为函数式编程讲究的是不可变）；需要用<code>asSequence()</code>转成序列再处理；</li>
<li>sequence是惰性求值的，类似Haskell中的设计。当然java中的stream也是惰性求值的；</li>
<li>因为支持惰性求值，所以也支持无限长序列，如<code>val naturalNum=generateSequences(0){it + 1}</code>；</li>
</ol>
<h2 id="泛型编程">泛型编程</h2>
<ol>
<li>kotlin泛型的语法和java区别不大，只是类型约束这里用<code>:</code>而不是<code>extend</code>；</li>
<li>可以使用内联函数避免泛型擦除，语法是：</li>
</ol>
<pre><code class="language-kotlin">inline fun&lt;reified T&gt; getType(){
    return T::class.java
}
</code></pre>
<p>这种函数无法在java中被调用；</p>
<ol start="3">
<li>如果在定义的泛型类和泛型⽅法的泛型参数前⾯加上out关键词，说明这个泛型类及泛型⽅法是协变，简单来说类型A是类 型B的子类型，那么<code>Generic&lt;A&gt;</code>也是<code>Generic&lt;B&gt;</code>的⼦类型；</li>
<li>关键词<code>in</code>用于实现泛型逆变；作用和上面正好相反；</li>
</ol>
<h2 id="元编程">元编程</h2>
<p>对于kotlin而言，由于不支持宏或者模板，剩下能讨论的元编程其实就只剩反射了。</p>
<ol>
<li>反射这块的内容用的时候再查，这里不做记录，因为平时用的不多；值得一提的是kotlin有个<code>KClass</code>，里面是kotlin特有的类型；</li>
<li>使用<code>annotation</code>创建注解，用法和java类似；</li>
</ol>
<h2 id="异步支持">异步支持</h2>
<ol>
<li>
<p>kotlin支持协程，且协程的设计比较复杂；</p>
</li>
<li>
<p>使用<code>runBlocking</code>会阻塞等待作用域内的协程执行完毕，一般用于main函数；</p>
</li>
<li>
<p>使用<code>coroutineScope</code>关键字创建协程作用域，在所有已启动子协程执行完毕之前该作用域不会结束；</p>
</li>
<li>
<p>使用<code>GlobalScope</code>创建全局作用域；</p>
</li>
<li>
<p>使用<code>launch</code>在上面创建的作用域里创建一个新协程；</p>
</li>
<li>
<p><code>launch</code>内的函数可以单独提取出来，但是需要增加<code>suspend</code>关键字；</p>
</li>
<li>
<p><code>launch</code>返回一个<code>Job</code>对象，可以被取消掉；</p>
</li>
<li>
<p>但是无法强制取消，必须在代码里做取消检测（如检测<code>isActive</code>）；</p>
</li>
<li>
<p>一般需要在<code>launch</code>代码块里进行<code>finally</code>检测，从而释放资源；</p>
</li>
<li>
<p>注意<code>finally</code>的代码不一定能执行完毕(主要是不能调用delay），如果需要确保这一点，使用<code>withContext(NonCancellable)</code>来强制保证；</p>
</li>
<li>
<p>一般取消协程是为了避免超时，在最外围加上<code>withTimeout</code>或者<code>withTimeoutOrNull</code>即可；</p>
</li>
<li>
<p>除了<code>launch</code>之外，还可以使用<code>async</code>启动协程，与前者不同的是，它返回一个<code>Deferred</code>，类似其他语言中的promise，可以使用<code>.await</code>等待结果；</p>
</li>
<li>
<p>换句话说<code>launch</code>有点类似返回<code>void</code>的函数，<code>async</code>则是有返回值的函数；</p>
</li>
<li>
<p><code>launch</code>会立刻启动，但是<code>async</code>可以加上<code>(start = CoroutineStart.LAZY)</code>改为惰性启动，即需要手动调用<code>.start</code>来启动；</p>
</li>
<li>
<p>很容易看出，kotlin与go协程的区别之一，就是协程作用域的设计。协程作用域主要是为了将相关工作分组；</p>
</li>
<li>
<p>协程作用域中某个协程抛出异常，会导致其他协程立刻被取消；当一个父协程被取消的时候，所有它的子协程也会被递归的取消；一个父协程总是等待所有的子协程执行结束，无须显式join；</p>
</li>
<li>
<p>kotlin并不推荐直接是使用全局async函数（像其他语言那种设计），即<code>GlobalScope.async</code>，因为全局作用域中的协程并不满足上面那条规则；</p>
</li>
<li>
<p>使用协程作用域+协程，被称为结构化并发；</p>
</li>
<li>
<p><code>async</code>和<code>launch</code>都可以显式指定调度策略，这包括：</p>
<ol>
<li>不传参数：从启动它的coroutineScope中继承；</li>
<li><code>Dispatchers.Unconfined</code>，非受限调度器，可能会使用不同的线程来调度协程中不同的部分（每当遇到被挂起的调用，就视为一个新的部分），高级特性，一般不会使用；</li>
<li><code>Dispatchers.Default</code>，默认调度器，使用共享的线程池；</li>
<li><code>newSingleThreadContext(&quot;MyOwnThread&quot;)</code>，启动一个新线程；</li>
</ol>
</li>
<li>
<p>给jvm加上<code>-Dkotlinx.coroutines.debug</code>的参数，打印日志时就会打印出协程的名称，方便调试；</p>
</li>
<li>
<p>可以给<code>async</code>或者<code>launch</code>加上<code>CoroutineName</code>参数来给协程命名；</p>
</li>
<li>
<p>给<code>async</code>/<code>launch</code>加多个参数，需要使用<code>+</code>来连接，例如：<code>launch(Dispatchers.Default + CoroutineName(&quot;test&quot;))</code>；</p>
</li>
<li>
<p>kotlin支持异步流，将函数返回值改为<code>Flow</code>，然后通过<code>emit</code>逐个抛出数据；调用端使用<code>collect</code>收集值；</p>
</li>
<li>
<p>kotlin支持<code>Channel</code>抽象，用法很像go中的channel；</p>
</li>
<li>
<p>kotlin内置了actor支持，但是官方已经不再推荐使用；</p>
</li>
<li>
<p>有类似go的<code>select</code>支持，但是目前还是实验性质的；</p>
</li>
</ol>
<p>总的来说，相比于go，kotlin的协程设计的有点过于复杂了，废案了好几次。所以设计一门语言还是没那么容易的。</p>

</article>


      
        <div class="my-4">
    
    <a href="https://yiuterran.github.io/blog/tags/kotlin/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#kotlin</a>
    
</div>
      

      



      
        <div class="py-2">
  
    <div class="my-8 flex flex-col items-center md:flex-row">
      <a href="https://yiuterran.github.io/blog/authors/tryao/" class="md:me-4 text-primary-text h-24 w-24">
        
        
          <img
            src="https://yiuterran.github.io/blog/images/avatar.png"
            class="bg-primary-bg w-full rounded-full"
            alt="Avatar"
          />
        
      </a>
      <div class="mt-4 w-full md:mt-0 md:w-auto">
        <a
          href="https://yiuterran.github.io/blog/authors/tryao/"
          class="mb-2 block border-b pb-1 text-lg font-bold"
        >
          <h3>个人介绍</h3>
        </a>
        <span class="block pb-2">兴趣使然的程序员，博而不精，乐学不倦</span>
        
          
          
          
          
          <a href="mailto:yaotairan@gmail.com" class="me-2">
            <i class="fas fa-envelope"></i>
          </a>
        
          
          
          
          
          <a href="https://github.com/YiuTerran" class="me-2">
            <i class="fab fa-github"></i>
          </a>
        
      </div>
    </div>
  
</div>

      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
        <span class="text-primary-text block font-bold"
          >上一页</span
        >
        <a href="https://yiuterran.github.io/blog/posts/%E8%BE%B9%E7%BC%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E9%80%89%E5%9E%8B/" class="block">边缘服务器管理工具选型</a>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="https://yiuterran.github.io/blog/posts/kubeedge%E8%A6%81%E7%82%B9%E7%AC%94%E8%AE%B0/" class="block">KubeEdge要点笔记</a>
      
    </div>
  </div>


      



  <script id="utterances" src="https://utteranc.es/client.js"
            issue-term=title
            repo=YiuTerran/blog-comment
              theme=preferred-color-scheme
        crossorigin="anonymous"
        async>
</script>
<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
    
      <div class="col-span-2">
        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>本页内容</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#语法要点">语法要点</a></li>
    <li><a href="#面向对象">面向对象</a></li>
    <li><a href="#数据结构">数据结构</a></li>
    <li><a href="#泛型编程">泛型编程</a></li>
    <li><a href="#元编程">元编程</a></li>
    <li><a href="#异步支持">异步支持</a></li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://github.com/YiuTerran">tryao</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
