<!DOCTYPE html>
<html lang='zh' dir='ltr' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Elastic Observability系统搭建 | 应许之地</title>

<meta name="generator" content="Hugo Eureka 0.9.0" />
<link rel="stylesheet" href="https://yiuterran.github.io/blog/css/eureka.min.css">
<script defer src="https://yiuterran.github.io/blog/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C0R8DENDJ0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'G-C0R8DENDJ0');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://yiuterran.github.io/blog/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png">

<meta name="description"
  content="随着ES v8.4的发布，es对于可观测性三支柱（Metric/Trace/Log）都具有较为完备的支持，Alert功能也能满足一般需求，kibana的">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章列表",
      "item":"https://yiuterran.github.io/blog/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Elastic Observability系统搭建",
      "item":"https://yiuterran.github.io/blog/posts/es-stack%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E8%90%BD%E5%9C%B0/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://yiuterran.github.io/blog/posts/es-stack%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E8%90%BD%E5%9C%B0/"
    },
    "headline": "Elastic Observability系统搭建 | 应许之地","datePublished": "2022-10-12T17:52:42+08:00",
    "dateModified": "2022-10-12T17:52:42+08:00",
    "wordCount":  15446 ,
    "publisher": {
        "@type": "Person",
        "name": "C. Wang",
        "logo": {
            "@type": "ImageObject",
            "url": "https://yiuterran.github.io/blog/images/icon.png"
        }
        },
    "description": "随着ES v8.4的发布，es对于可观测性三支柱（Metric\/Trace\/Log）都具有较为完备的支持，Alert功能也能满足一般需求，kibana的"
}
</script><meta property="og:title" content="Elastic Observability系统搭建 | 应许之地" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://yiuterran.github.io/blog/images/icon.png">


<meta property="og:url" content="https://yiuterran.github.io/blog/posts/es-stack%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E8%90%BD%E5%9C%B0/" />




<meta property="og:description" content="随着ES v8.4的发布，es对于可观测性三支柱（Metric/Trace/Log）都具有较为完备的支持，Alert功能也能满足一般需求，kibana的" />




<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="应许之地" />






<meta property="article:published_time" content="2022-10-12T17:52:42&#43;08:00" />


<meta property="article:modified_time" content="2022-10-12T17:52:42&#43;08:00" />



<meta property="article:section" content="posts" />




<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 ps-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="https://yiuterran.github.io/blog/" class="me-6 text-primary-text text-xl font-bold">应许之地</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="https://yiuterran.github.io/blog/authors/tryao/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">作者</a>
            <a href="https://yiuterran.github.io/blog/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="grow pt-16">
    <div class="ps-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">Elastic Observability系统搭建</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="me-6 my-2">
        <i class="fas fa-calendar me-1"></i>
        <span>2022-10-12</span>
    </div>
    <div class="me-6 my-2">
        <i class="fas fa-clock me-1"></i>
        <span>31分钟阅读时长</span>
    </div>
    
    

    
</div>
        
        
        

        <div class="content">
            <p>随着ES v8.4的发布，es对于可观测性三支柱（Metric/Trace/Log）都具有较为完备的支持，Alert功能也能满足一般需求，kibana的看板功能经过这么多年的迭代，可用性也比较好了。最重要的是，<strong>兼容OpenTelemetry的标准</strong>也保证如果用的不爽也可以用其他开源组件替换，所以项目组目前搭建监控平台，经过评估还是决定优先用这一套。</p>
<h2 id="elasticsearch部分">ElasticSearch部分</h2>
<h3 id="安装es">安装ES</h3>
<p>目前公司用的还是CentOS，所以用RPM安装就行，官方指南<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html">地址</a>.</p>
<p>另外ES已经支持k8s安装，有需要的话建议<a href="https://www.elastic.co/guide/en/cloud-on-k8s/current/index.html">使用</a>.</p>
<pre><code class="language-sh">rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch

cat&gt;/etc/yum.repos.d/elasticsearch.repo&lt;&lt;EOF
[elasticsearch]
name=Elasticsearch repository for 8.x packages
baseurl=https://artifacts.elastic.co/packages/8.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=0
autorefresh=1
type=rpm-md
EOF

sudo yum install -y --enablerepo=elasticsearch elasticsearch 
</code></pre>
<p>es应该是有中国的CDN，所以下载很快。在安装过程中会自动生成超管密码：</p>
<blockquote>
<p>The generated password for the elastic built-in superuser is : <xxxx></p>
</blockquote>
<p>默认安装的es是单机模式，如果想要加入已有的集群，则在该集群任意节点生成token：</p>
<pre><code class="language-bash">/usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token -s node
</code></pre>
<p>然后在这个新安装的节点上配置生成的token:</p>
<pre><code class="language-bash">/usr/share/elasticsearch/bin/elasticsearch-reconfigure-node --enrollment-token &lt;enrollment-token&gt;
</code></pre>
<p>接着就可以启动服务了：</p>
<pre><code class="language-bash">sudo systemctl daemon-reload
sudo systemctl enable elasticsearch.service
sudo systemctl start elasticsearch.service
</code></pre>
<p>可以用以下命令确认es运行状态：</p>
<pre><code class="language-bash">curl --cacert /etc/elasticsearch/certs/http_ca.crt -u elastic https://localhost:9200 
</code></pre>
<p>这里就输入刚才自动生成的密码即可。</p>
<p>如果是从旧版ES进行升级，ES只保证一个大版本的兼容性，所以从6.x只能先升级到7.x，然后再升级到8.x。甚至7.17之前的版本还要先升级到7.17才行。每个结点独立升级一般不影响服务可用性。特别注意的是大版本升级可能会影响Rest API的兼容性，所以一定要非常谨慎。</p>
<h3 id="配置es">配置ES</h3>
<p>所有配置集中在<code>/etc/elasticsearch</code>下面，该文件夹以及所有子文件的权限默认都是<code>root:elasticsearch</code>。JVM相关的配置在<code>/etc/sysconfig/elasticsearch</code>下，其他的配置则集中在<code>/etc/elasticsearch/elasticsearch.yml</code>中。二进制文件在<code>/usr/share/elasticsearch/bin</code>下，可以考虑加到PATH里。</p>
<p>使用systemd启动的服务，则需要配置systemd的资源限制，打开<code>/usr/lib/systemd/system/elasticsearch.service</code>可以看到默认的资源限制。如果不满足需求，可以通过<code>sudo systemctl edit elasticsearch</code>来生成覆盖配置，完事之后通过<code>sudo systemctl daemon-reload</code>重新加载配置即可生效。</p>
<p>es在安装时会自动生成CA证书，在<code>/etc/elasticsearch/certs</code>下，客户端所在的机器需要copy证书并信任，才能正常进行HTTPS通信。<strong>注意需要在<code>xpack.security.http.ssl</code>下增加一个配置：<code>verification_mode: certificate</code></strong>，这个默认没有写。</p>
<p>ES可以通过<code>PUT /_cluster/settings</code>的API直接修改整个集群的配置，不必一台一台去改配置文件，当然kibana上修改也行。只有一小部分需要通过手动修改配置文件指定（如集群的名字等）。es的配置项非常多，不过大部分保持默认即可，需要注意的主要是<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/important-settings.html">这里</a>.</p>
<p>尤其注意，一旦打开集群模式，即将<code>network.host</code>配置打开，es启动时就会进行严格自检，如果有不满足的配置，则无法正常启动。<strong>需要注意的点包括</strong>：</p>
<ul>
<li>修改文件描述符限制；</li>
<li>关闭swap；</li>
<li>在<code>sysctl.conf</code>里面设置<code>vm.max_map_count=262144</code>；</li>
<li>调整最大线程数限制；</li>
<li>根据需求调整jvm、dns设置，以及tcp重传超时设置；</li>
<li>确认/tmp文件夹允许执行二进制文件；</li>
</ul>
<p>在配置完成之后，<strong>需要删除掉配置文件中的<code>cluster.initial_master_nodes</code></strong>，再重新启动。</p>
<p>另外，如果是单机启动，可以加上<code>discovery.type: single-node</code>。</p>
<p>可以通过设置</p>
<pre><code class="language-yaml">xpack.security.http.ssl.enabled: false
xpack.security.transport.ssl.enabled: false
</code></pre>
<p>关闭ssl加密通信，<strong>但是最好别这么做</strong>，因为下面的Fleet会强制使用SSL。</p>
<p>重启之后使用curl命令重新测试一下，保证配置文件没改错。</p>
<h3 id="集群管理">集群管理</h3>
<p>建议先在单节点上搭建kibana，之后再修改配置成为集群。</p>
<ol>
<li>修改原来的单点es，主要修改如下配置：</li>
</ol>
<pre><code class="language-yaml">cluster.name: your-cluster
node.name: node-1
# 最重要的
network.host: your-LAN-addr
# 本地，以及其他节点的内网地址
discovery.seed_hosts: [&quot;127.0.0.1&quot;]
# master备选
cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;, &quot;node-3&quot;]
transport.host: 0.0.0.0
</code></pre>
<p>然后将<code>elasticsearch.yml</code>, <code>elasticsearch.keystore</code>和<code>certs</code>文件夹copy到其他节点。</p>
<ol start="2">
<li>先重启第一个节点，让节点自检配置文件，无误后再操作其他节点加入集群；</li>
<li>将copy过来的文件移动到<code>/etc/elasticsearch</code>下面，并修改owner为<code>root:elasticsearch</code>，这里假设用root操作；</li>
<li>certs下的<code>p12</code>文件，需要修改权限为660；</li>
<li>新节点的sysctl.conf以及limits.conf也要配置，参考单点时的描述；</li>
<li>新节点需要修改yaml中的<code>node.name</code>以及<code>network.host</code>配置；并修改<code>discovery.seed_hosts</code>加入第一个节点的内网地址；</li>
<li>使用<code>systemctl start</code>启动服务；或者使用官网提示的<code>token</code> enroll方式加入（仅适用于第一次启动进程）；</li>
<li>注意：<strong>如果需要修改集群配置，直接删除配置的data目录下的所有文件</strong>；</li>
<li>修改kibana以及其他组件的配置，指向整个es集群；</li>
<li>进入kibana，打开堆栈监测，可以看到有3个结点；</li>
</ol>
<p>整个集群的逻辑就是有个初始master节点作为种子，然后其他结点通过seed_hosts连接这个初始节点，最终组成集群。初始的种子节点如果需要重启，也需要在seed_hosts里面加入其他节点。如果整个集群全部都宕机了，就要重复一遍这个流程了。</p>
<h2 id="kibana部分">Kibana部分</h2>
<h3 id="安装kibana">安装kibana</h3>
<p>kibana版本要和es一致，方法也差不多，这里还是用rpm安装：</p>
<pre><code class="language-bash">yum install --enablerepo=elasticsearch kibana
</code></pre>
<p>repo的地址和es是一致的，我们这里在同一台设备上安装，所以直接安装就行。</p>
<p>这里可以为kibana生成token，也可以生成用户名密码。推荐使用token。</p>
<p>token生成：</p>
<pre><code class="language-bash">/usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token -s kibana
# 复制生成的token并
/usr/share/kibana/bin/kibana-setup --enrollment-token &lt;token&gt;
</code></pre>
<p>如果要设置<code>kibana_system</code>的密码：</p>
<pre><code class="language-bash">bin/elasticsearch-reset-password -u kibana_system
</code></pre>
<p>这里会生成一个随机密码。</p>
<h3 id="配置kibana">配置kibana</h3>
<p>配置文件在/etc/kibana下，需要配置的一般包括：</p>
<pre><code class="language-yaml">server.port: 5601
server.host: &quot;0.0.0.0&quot;
server.name: &quot;your-system-name&quot;
elasticsearch.hosts: []
# 用户名和密码或者token设置一个就可以
elasticsearch.username: &quot;kibana_system&quot;
# 刚才生成的密码
elasticsearch.password: &quot;xxxx&quot;
# 或：刚才复制的token
# elasticsearch.serviceAccountToken: &quot;&quot;
# 语言改成中文，不过中文翻译实际上有点问题……可以的话用英文更好
i18n.locale: &quot;zh-CN&quot;
# 外网访问地址，如果是有域名则配置域名，或者一般配置反代的地址
server.publicBaseUrl: &quot;http://&lt;out-ip&gt;:5601&quot;
</code></pre>
<p>改好之后通过<code>systemctl start kibana</code>启动服务，通过<code>journalctl -u kibana</code>查看日志，如果看到<code>Kibana is now available</code>，那就是启动完成了。也可以通过netstat查看端口5601是否启动。</p>
<p>通过浏览器访问该地址的5601端口，即可打开登录页。使用内置elastic账户+超管密码登陆即可进行后续操作。</p>
<h2 id="安装fleet-server">安装Fleet Server</h2>
<p>Fleet Server是接受Elastic Agent或者各种Beat发送过来的数据并存储到ES的服务。比较蛋疼的是，FleetServer是集成在ElasticAgent这个二进制文件里面的，所以agent体积巨大。</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/fleet-server-on-prem-deployment-20230307194341712.png" alt="Fleet Server on-premises deployment model"></p>
<p>MetricBeats等beats工具则比较轻量一些，可以直接传输数据到ES，不过此类工具就无法通过kibana直接进行配置升级等管理了。</p>
<p>这里还是先使用Agent+Fleet的方式安装，方便后续升级管理：</p>
<ol>
<li>
<p>先在kibana的<code>Management-Fleet-设置</code>里，设置安装fleet的主机。由于是无状态服务，所以可以有一个或者多个地址（多个的话使用负载均衡地址）。我们这里都装一起，所以Fleet地址就是es这台机器的内网地址。注意这里<strong>只能用HTTPS</strong>；</p>
</li>
<li>
<p>切到代理策略的tab中，创建一个代理策略，填好名称并同样收集这台设备本身的收集，<strong>注意一台主机只能分配一个代理策略，虽然感觉不太合理，但是勉强也够用</strong>；</p>
</li>
<li>
<p>创建之后，点“添加集成”，进去搜<code>FleetServer</code>，配置服务的Host和Port，可以配置一个最大流量。注意<strong>命名空间</strong>那里填的是环境，一般是<code>dev</code>,<code>test</code>之类的；高级设置的地址里填<code>0.0.0.0</code>，端口可以用默认的；</p>
</li>
<li>
<p>登陆ES所在的机器，通过</p>
</li>
</ol>
<p><code>/usr/share/elasticsearch/bin/elasticsearch-keystore show xpack.security.http.ssl.keystore.secure_password</code></p>
<p>可以看到<code>http.p12</code>的密码。</p>
<ol start="5">
<li>然后切到<code>/etc/elasticsearch/certs</code>下面，输入：</li>
</ol>
<p><code>openssl pkcs12 -in http.p12 -out http_cert.crt -clcerts -nokeys</code>，根据提示输入上面获得的密码，生成crt文件；</p>
<ol start="6">
<li><code>openssl pkcs12 -in http.p12 -out http.key -nocerts -nodes</code>，重复输入密码，生成key文件；</li>
<li>这样我们就凑够了安装Fleet要的所有资料。切到代理的tab页，点击advanced，选择第2步创建的策略，部署模式选择生产，主机选择在第1步中创建的那个。然后选择主机平台，将对应的cli语句copy下来，并修改<code>&lt;&gt;</code>里的内容，最后的形式大概如下：</li>
</ol>
<pre><code class="language-bash">sudo ./elastic-agent install --url=https://10.20.121.2:8220 \
  --fleet-server-es=https://10.20.121.2:9200 \
  --fleet-server-service-token=&lt;your token&gt; \
  --fleet-server-policy=4e3a7e30-4b70-11ed-bea5-2fb24f0ee1fa \
  --certificate-authorities=/etc/elasticsearch/certs/http_ca.crt \
  --fleet-server-es-ca=/etc/elasticsearch/certs/http_ca.crt \
  --fleet-server-cert=/etc/elasticsearch/certs/http_cert.crt \
  --fleet-server-cert-key=/etc/elasticsearch/certs/http.key
</code></pre>
<p>如果在FleetServer前面挂了一个负载均衡的反代，那<code>--url</code>后面就要改成反向代理的地址了，实际上<code>es</code>的地址也可以改成反代的地址。</p>
<p>这里的es和fleet用了同一个ca文件，官方建议是为每个fleet-server生成不同的ca以及key/cert，这太麻烦了，所以我们这里共用了同一套。</p>
<p>如果害怕泄露ca文件导致的安全问题，可以为fleet-server单独生成一套，生成方法是：</p>
<pre><code class="language-bash">/usr/share/elasticsearch/bin/elasticsearch-certutil cert \
  --name fleet-server \
  --ca-cert /path/to/ca/ca.crt \
  --ca-key /path/to/ca/ca.key \
  --dns your.host.name.here \
  --ip 192.0.2.1 \
  --pem
</code></pre>
<p>把dns和ip换成fleet server所在的机器名和ip就行。</p>
<p>如果需要卸载Fleet(或者说Elastic Agent)，运行<code>/opt/Elastic/Agent/elastic-agent uninstall</code>即可。</p>
<h2 id="安装elastic-agent">安装Elastic Agent</h2>
<p>由于FleetServer和ElasticAgent实际上是同一个二进制文件，所在FleetServer所在的机器就没必要再装agent了。这里另外找一台主机来安装agent.</p>
<p><strong>非k8s环境：</strong></p>
<ol>
<li>登陆要安装agent的机器，先配置ca证书（适用于centos）：</li>
</ol>
<pre><code class="language-bash">yum install -y ca-certificates
update-ca-trust enable
# 把es生成的ca证书copy到agent所在的设备
mv http_ca.crt /etc/pki/ca-trust/source/anchors/
update-ca-trust extract
</code></pre>
<ol start="2">
<li>切到代理策略页面，点击添加代理，选择在Fleet中注册，然后copy下面生成的命令行代码，到要监控的机器上执行；</li>
<li>如果Fleet有多个Server，且没有使用反向代理，这里会默认使用第一个的地址，可以手动修改一下再执行；</li>
<li>一切正常的话，主机就会显示在代理页面上；</li>
</ol>
<p><strong>k8s环境：</strong></p>
<ol>
<li>实际上仍然是在宿主机上安装，不过是通过DaemonSet与k8s整合；</li>
<li>具体流程请参考<a href="https://www.elastic.co/guide/en/fleet/current/running-on-kubernetes-managed-by-fleet.html">这里</a>；</li>
<li>仍然推荐先在宿主机上信任证书；</li>
</ol>
<h2 id="安装metricbeatecs可选">安装Metricbeat(ECS/可选)</h2>
<h3 id="基础配置">基础配置</h3>
<p>对ES的简单监控可以用es自带的monitor，将<code>xpack.monitoring.collection.enabled</code>打开即可，可以在kibana上面操作完成。</p>
<p>Elastic Agent虽然设计的是ALL-IN-ONE，但是很多功能都还没集成进去(v8.4)，比如监控ElasticSearch自身。所以如果不用ES自带的监控，就需要安装MetricBeat来完成该功能。</p>
<blockquote>
<p>MetricBeat也无法监控FleetServer和ElasticAgent，所以如果你在一台设备上同时安装了FleetServer和ElasticSearch本身，那么要安装三个Agent。</p>
<p>不过估计到v9的时候ElasticAgent就会集成所有常见的功能了，现在处于过渡时期。</p>
</blockquote>
<p>MetricBeat就是完全单独安装了，通过rpm下载或者直接yum安装。</p>
<p>打开<code>/etc/metricbeat/</code>下的配置文件修改如下配置：</p>
<pre><code class="language-yaml">output.elasticsearch:
  # Array of hosts to connect to.
  hosts: [&quot;https://localhost:9200&quot;]

  # Protocol - either `http` (default) or `https`.
  protocol: &quot;https&quot;

  # Authentication credentials - either API key or username/password.
  #api_key: &quot;id:api_key&quot;
  username: &quot;elastic&quot;
  password: &quot;${ES_PWD}&quot;
  ssl:
    enabled: true
    ca_trusted_fingerprint: &quot;${ES_PRINT}&quot;
</code></pre>
<p>es的密码最好不要明文写在配置文件里，通过</p>
<pre><code class="language-bash">metricbeat keystore create
metricbeat keystore add ES_PWD --force
metricbeat keystore add ES_PRINT
</code></pre>
<p>将敏感信息保存在钥匙链里。</p>
<p>其中ES_PRINT就是es那个ca证书的指纹，通过<code>openssl x509 -fingerprint -sha256 -in /etc/elasticsearch/certs/http_ca.crt</code>可以看到，<strong>特别注意的是需要去掉其中的冒号<code>:</code></strong>，将其转为一个16进制字符串。</p>
<blockquote>
<p>这里建议将monitor的配置也打开，监控自身：monitor.enabled=true</p>
</blockquote>
<h3 id="采集es信息">采集ES信息</h3>
<p>然后到kibana的堆栈管理（这里翻译有点问题…），修改内置账户<code>remote_monitoring_user</code>的密码，记下来。</p>
<p>然后激活metricbeat的es采集功能：</p>
<pre><code class="language-bash">metricbeat modules enable elasticsearch-xpack
</code></pre>
<p>配置<code>modules.d/elasticsearch-xpack.yml</code>，修改如下内容：</p>
<pre><code class="language-yaml">- module: elasticsearch
  xpack.enabled: true
  period: 10s
  hosts: [&quot;https://localhost:9200&quot;]
  # 上面设置的账户
  username: &quot;internal_metric&quot;
  #上面设置的密码
  password: &quot;xxxx&quot;
</code></pre>
<p>另外就是把ca证书标记为系统信任，这样就不需要再配置ssl了。</p>
<p>由于agent那边已经采集了system，所以这边最好用<code>metricbeat modules disable system</code>关掉避免重复采集。</p>
<h3 id="启动服务">启动服务</h3>
<p>然后启动MetricBeat：</p>
<pre><code class="language-bash"># 该步骤较慢，请耐心等待
metricbeat setup
systemctl enable metricbeat
systemctl start metricbeat
</code></pre>
<p>可以通过<code>journalctl -u metricbeat</code>查看日志，如果没有ERROR应该就是OK了（日志很长，可以用左右箭头移动看具体错误）。</p>
<h2 id="安装metricbeatk8s">安装Metricbeat(k8s)</h2>
<h3 id="基础配置-1">基础配置</h3>
<p>下载metricbeat配置文件，使用命令</p>
<pre><code class="language-bash">curl -L -O https://raw.githubusercontent.com/elastic/beats/8.4/deploy/kubernetes/metricbeat-kubernetes.yaml
</code></pre>
<blockquote>
<p>配置文件下载之后，首先将文件中所有的namespace修改为metricbeat</p>
</blockquote>
<p>找到Metricbeat配置ES信息的位置，将<code>ELASTICSEARCH_HOST</code>和<code>ELASTICSEARCH_PORT</code>修改为对应ElasticSearch的IP和端口，将<code>ELASTICSEARCH_USERNAME</code>和<code>ELASTICSEARCH_PASSWORD</code>修改为对应的ElasticSearch用户名和密码</p>
<pre><code class="language-yml">        env:
        - name: ELASTICSEARCH_HOST
          value: 10.20.121.2
        - name: ELASTICSEARCH_PORT
          value: &quot;9200&quot;
        - name: ELASTICSEARCH_USERNAME
          value: elastic
        - name: ELASTICSEARCH_PASSWORD
          value: a-WxDYOh65KAIPSx1O6s
</code></pre>
<p>另外，metricbeat默认的内存配置太小，需要改大，这里将<code>limits</code>调整为500MB</p>
<pre><code class="language-yml">        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 100Mi
</code></pre>
<p>如果es没有启用ssl，那么到这里基础配置就结束了，如果启用了ssl，还需要配置ssl信息
找到配置文件中的<code>output.elasticsearch</code>部分，将其修改为</p>
<pre><code class="language-yml">output.elasticsearch:
  hosts: ['${ELASTICSEARCH_HOST:elasticsearch}:${ELASTICSEARCH_PORT:9200}']
  username: ${ELASTICSEARCH_USERNAME}
  password: ${ELASTICSEARCH_PASSWORD}
  protocol: https
  ssl:
      enabled: true
      ca_trusted_fingerprint: &quot;${ES_PRINT}&quot;
</code></pre>
<p>其中ES_PRINT就是es那个ca证书的指纹，使用同ECS中的metricbeat配置，参考上文.</p>
<h3 id="服务监控配置">服务监控配置</h3>
<p>首先确保各k8s中的服务都已引入prometheus并以通过http接口暴露metric。
找到配置文件中的<code>metricbeat.autodiscover</code>配置项，将其修改为：</p>
<pre><code class="language-yml">metricbeat.autodiscover:
  providers:
    - type: kubernetes
      include_labels: [&quot;app&quot;]
      templates:
        - condition:
            contains:
              kubernetes.labels.app: &quot;sim-iotgateway&quot;
          config:
            - module: prometheus
              metricsets: [&quot;collector&quot;]
              hosts: &quot;${data.host}:${data.port}&quot;
              metrics_path: /metrics/prometheus
              period: 30s      
</code></pre>
<p>上面使用的是metricbeat的自动探测功能，自动监控了iot的iotgateway服务，其中的<code>metrics_path</code>是服务暴露的metric接口路径，period是metric采集周期。下面这一段代表的是要采集那个服务的metric。</p>
<pre><code class="language-yml">templates:
        - condition:
            contains:
              kubernetes.labels.app: &quot;sim-iotgateway&quot;
</code></pre>
<p>这里使用了metricbeat的标签过滤功能，要配置哪个服务，就过滤哪个服务的标签即可。</p>
<p>如果要新增hermes服务的监控，只需新增对应的配置</p>
<pre><code class="language-yml">metricbeat.autodiscover:
  providers:
    - type: kubernetes
      include_labels: [&quot;app&quot;]
      templates:
        - condition:
            contains:
              kubernetes.labels.app: &quot;sim-iothermes&quot;
          config:
            - module: prometheus
              metricsets: [&quot;collector&quot;]
              hosts: &quot;${data.host}:${data.port}&quot;
              metrics_path: /metrics/prometheus
              period: 30s
    - type: kubernetes
      include_labels: [&quot;app&quot;]
      templates:
        - condition:
            contains:
              kubernetes.labels.app: &quot;sim-iotgateway&quot;
          config:
            - module: prometheus
              metricsets: [&quot;collector&quot;]
              hosts: &quot;${data.host}:${data.port}&quot;
              metrics_path: /metrics/prometheus
              period: 30s    
</code></pre>
<p>每个服务的标签labels，可以在对应服务k8s的yaml中找到，例如：</p>
<pre><code class="language-yml">apiVersion: v1
kind: Pod
metadata:
  annotations:
    cattle.io/timestamp: &quot;2022-10-18T09:48:42Z&quot;
    kubernetes.io/psp: ack.privileged
  creationTimestamp: &quot;2022-10-21T09:31:34Z&quot;
  generateName: deploy-sim-iothermes-5bc86c5bb7-
  labels:
    app: sim-iothermes
    pod-template-hash: 5bc86c5bb7
</code></pre>
<h3 id="部署">部署</h3>
<p>修改完<code>metricbeat-kubernetes.yaml</code>之后，在k8s机器上执行下述命令即可</p>
<blockquote>
<p>注意，这里采用的是DaemonSet模式</p>
</blockquote>
<pre><code class="language-bash">kubectl create -f metricbeat-kubernetes.yaml
</code></pre>
<p>部署完成后，也可在configmap中的metricbeat.yml中进行监控服务的增删.</p>
<h2 id="安装filebeat">安装Filebeat</h2>
<p>同样，如果不想使用ElasticAgent的custom logs，out-of-box地收集elasticsearch的日志还是要装filebeat，流程也很类似：</p>
<pre><code class="language-bash">filebeat keystore create
filebeat keystore add ES_PWD
filebeat keystore add ES_PRINT
</code></pre>
<p>然后修改<code>filebeat.yml</code>，将<code>output.elasticsearch</code>设置为类似MetricBeat的配置。inputs那边不用管，因为我们使用modules配置。</p>
<blockquote>
<p>另外这里可以将moniter的enable打开，监控自身的metric</p>
</blockquote>
<p>然后<code>filebeat modules enable elasticsearch</code>，修改<code>elasticsearch.yml</code>，设置<code>enabled=true</code>。</p>
<p>最后：</p>
<pre><code class="language-bash">filebeat setup
systemctl enable filebeat
systemctl start filebeat
</code></pre>
<p>使用journalctl查看日志即可。</p>
<p>另外kibana所在的机器还要打开kibana的日志收集，配置方法类似。</p>
<p>在ES所在机器安装了MetricBeat和Filebeat之后，就可以在kibana的<strong>堆栈监测</strong>里面看到es相关信息，差不多就是下图的样子：</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/crdIyuoa97LKDjJ-20230307194342564.png" alt="image-20221017104832361"></p>
<p>如果仅仅使用es自带的monitor，则不会有下面的beats部分，<strong>同时也不会有log的监控</strong>。</p>
<h2 id="数据生命周期管理ilm">数据生命周期管理(ILM)</h2>
<p>在<strong>Stack Management</strong>-<strong>索引生命周期管理</strong>里管理index的生命周期策略，这里默认就会有filebeat和metricbeat自动创建index的生命周期，可以根据需求进行修改。冷阶段不支持搜索，除非有企业许可证。</p>
<p>Elastic Agent采集的Metric，则是默认使用<code>metrics</code>策略管理，即所有数据都在hot阶段，这里肯定需要自定义存储策略。</p>
<p>进入<strong>索引管理</strong>-<strong>数据流</strong>，搜索prometheus可以看到<code>metrics-prometheus.collector-test</code>，点击可以看到索引模板是<code>metrics-prometheus.collector</code>。到索引模板里clone这个模板，将优先级改到250（或者直接改这个索引模板的配置也可以），在<strong>索引配置</strong>页面加上：</p>
<pre><code class="language-json">{
  &quot;lifecycle&quot;: {
    &quot;name&quot;: &quot;metricbeat&quot;
  }
}
</code></pre>
<p>点击保存。回到数据流tab，再次点击刚才的数据流，就会发现索引模板已经变成新的了，而且生命周期策略也改成<code>metricbeat</code>了。</p>
<p>在<code>索引模板</code>里面搜索<code>agent</code>，可以看到所有elastic agent自动创建的模板，可以看到<code>metrcis-</code>开头的默认的ILM都是<code>metrics</code>，建议根据自己的使用情况全部改成自定义的ILM。感觉这个设计不是很合理，期望后续的版本使用非托管策略方便修改。</p>
<h2 id="prometheus-metrics采集fleet">Prometheus Metrics采集(Fleet)</h2>
<p>Elastic Agent已经集成了Prometheus Metric采集功能（还是beta），当然我们也可以使用MetricBeat来完成。</p>
<p>生产环境推荐使用filebeat+metricbeat的方式采集日志和系统信息，等到Elastic Agent稳定之后再替换掉。而且beat目前采集信息可以送到kafka，避免把es压垮。这里为了方便还是直接用Fleet，毕竟我们的服务产生的数据量没那么大。</p>
<p>进入Fleet，选择代理策略，选择<strong>添加集成</strong>，搜索<code>Prometheus Metrics</code>，出来的是MetricBeat版本，点进去之后会提示你有agent版本，切换过去。我这边用的时候最新版是<code>0.13.0</code>，点击<code>添加Prometheus Metrics</code>按钮即可一键部署。</p>
<p>注意点击<strong>修改默认值</strong>，去修改服务的地址。</p>
<p>在discover那边，将索引切换到<code>metrics-*</code>，搜索<code>prometheus*:*</code>应该可以看到有数据采集过来。不过MetricBeat采集的数据使用的索引是<code>metricbeat-*</code>,两者默认使用不同的ILM，上文已经通过手动修改将二者都改成<code>metricbeat</code>的ILM了.</p>
<h2 id="uptime监控">Uptime监控</h2>
<p>可以使用heartbeat或者新的uptime app(在Observability-Uptime-Monitor右上角有个<code>监测管理</code>的入口)来监控接口或者主机的可用性，支持进行模拟浏览器/HTTP/TCP/ICMP的探测。</p>
<p>对于自建的服务，一般情况下，设置metrics就可以判断服务的存活性了。云主机的存活性一般不需要关心，边缘端或者自建机房可以考虑加一个ping探测。</p>
<p>不过，Uptime还可以是对第三方服务的，甚至可以用浏览器行为来进行前端自动化探测，如果<strong>服务依赖第三方接口</strong>，可以考虑加上相关探测。自建服务如果需要供外网访问，也可以将heartbeat安装在外网机器，从而进行端到端的探测。</p>
<p>由于暂时没有啥必须监控的东西，这里我们就先不进行配置了。</p>
<h2 id="应用日志采集">应用日志采集</h2>
<p>前面配置filebeat采集日志的流程已经写了，当然也可以用来收集自定义日志，只要配置yaml配置一下路径就行。</p>
<p>这里使用Elastic Agent来进行采集，其实流程差不多：简单来说，在Fleet中集成<code>Custom Logs</code>，配置上日志路径就OK了。</p>
<p>不过一般我们并不采集所有应用日志（因为大部分都是辣鸡信息），正确的做法是把重要信息先结构化成json日志，然后再采集那些结构化日志。ES规定了一份详细的日志规范，简称ECS，文档请参考<a href="https://www.elastic.co/guide/en/ecs/current/ecs-reference.html">这里</a>。保证所有的应用使用同样的字段才能更好的过滤信息，这其实是一种管理策略。</p>
<p>这里演示一下另外一个常用的场景，采集ERROR日志用来告警，这个一般并不需要结构化日志，直接提取日志中的ERROR行即可。</p>
<h3 id="数据预处理">数据预处理</h3>
<p>在数据传入es之前可以使用管道对数据进行预处理，在<code>Stack Management</code>-<code>采集</code>-<code>采集管道</code>里面建立处理流程即可。注意映射的字段尽量遵守上面的ECS规范。</p>
<p>对于plain text日志，最常用的processor是<code>dissect</code>（中文翻译是分解），<code>grok</code>和<code>script</code>三种，用来提取字段，其中grok用的其实就是正则匹配。</p>
<p>假设我们这里有golang服务日志格式如下：</p>
<blockquote>
<p>2022-08-18T15:54:52.866+0800    WARN    internal/kafka.go:37    [kafka]poll errors:[{ 0 client closed}]</p>
</blockquote>
<p>这里有文件路径，但这个字段只有debug模式下才打开，正常的日志格式则是这样的：</p>
<blockquote>
<p>2022-08-18T15:54:52.866+0800    WARN    [kafka]poll errors:[{ 0 client closed}]</p>
</blockquote>
<p>由于字段不固定，所以这个需求无法使用<code>dissect</code>完成，只能选择<code>grok</code>或者脚本。</p>
<p>这里用grok，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/grok.html">官方文档</a>，可以写下如下匹配规则：</p>
<blockquote>
<p>%{TIMESTAMP_ISO8601:@timestamp}%{SPACE}%{LOGLEVEL:log.level}%{SPACE}%{GREEDYDATA:message}</p>
</blockquote>
<p>先到kibana<strong>开发工具</strong>下面的<code>Grok Debugger</code>里面去测试，可以看到模拟结果为：</p>
<pre><code class="language-json">{
  &quot;@timestamp&quot;: &quot;2022-08-18T15:54:52.866+0800&quot;,
  &quot;message&quot;: &quot;internal/kafka.go:37    [kafka]poll errors:[{ 0 client closed}]&quot;,
  &quot;log&quot;: {
    &quot;level&quot;: &quot;WARN&quot;
  }
}
</code></pre>
<p>如果我们不想要中间的<code>internal/kafka.go:37</code>这部分，就稍微麻烦一些，定义</p>
<blockquote>
<p>CALLER (\s+([/\w_%!$@:.,+~-]+|\.)*:\d+)?</p>
</blockquote>
<p>然后将表达式改为：</p>
<blockquote>
<p>%{TIMESTAMP_ISO8601:@timestamp}%{SPACE}%{LOGLEVEL:log.level}%{CALLER}%{SPACE}%{GREEDYDATA:message}</p>
</blockquote>
<p>这样就可以强行把中间的caller部分过滤掉。</p>
<p>需要注意的是，在kibana界面上添加管道时，<strong>需要对<code>\</code>进行转义</strong>，即改为<code>(\\s+([/\\w_%!$@:.,+~-]+|\\.)*:\\d+)?</code>。</p>
<p>添加完成之后可以点击<strong>添加文档</strong>，在pipeline里再测试一次。同时也可以在后面添加别的pipeline进一步处理，比如添加新字段等。该功能的详细使用步骤可以参考<a href="https://juejin.cn/post/7129767885177618463">这里</a>。</p>
<p>部分预处理需要使用<a href="https://www.elastic.co/guide/en/elasticsearch/painless/current/painless-ingest-processor-context.html">painless脚本</a>，比如某些服务没有区分error日志与普通日志，那么需要drop掉warn等级以下的日志，可以用<code>ctx.log.level != 'WARN' &amp;&amp; ctx.log.level != 'ERROR'</code>。</p>
<p>一般同一种语言使用相同的日志格式，这里假设添加管道的名字为<code>golang-common-log-parser</code>，并创建一个<code>common-logs-policy</code>的策略，对所有应用日志生命周期进行统一管理。</p>
<p><strong>NOTE</strong>: 建议加一个处理失败则drop的处理器，避免部分数据格式问题导致的发送失败。</p>
<h3 id="配置索引模板">配置索引模板</h3>
<p>我们需要将上面的grok转换后的格式关联一个索引模板。</p>
<p>先创建一个组件模板以供复用，到<code>Stack Management</code>-<code>索引管理</code>下面，点击<strong>组件模板</strong>tab页下<strong>创建</strong>相关按钮，填入名称（如custom-logs@mapping），在mapping页面做好映射：</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/iOIGgqcJyrnQf1P-20230307194343074.png" alt="image-20221102111708534"></p>
<p>对应json如下：</p>
<pre><code class="language-json">{
  &quot;@timestamp&quot;: &quot;Date&quot;,
  &quot;log&quot;: {
      &quot;level&quot;: &quot;Keyword&quot;
  },
  &quot;message&quot;: {&quot;Other: match_only_text&quot;}
}
</code></pre>
<p>然后点击<strong>索引模板</strong>tab页上的按钮，创建一个索引模板，假设名为<code>golang-logs-template</code>，在<code>index patterns</code>下面填入<strong>日志索引的格式，如<code>logs_golang*</code></strong>，打开<code>Create data stream</code>，并将<strong>优先级设置为&gt;100的数值</strong>。点击下一步，添加刚才创建的组件模板，添加，在<code>index settings</code>中关联ILM：</p>
<pre><code class="language-json">{
    &quot;index&quot;:{
        &quot;lifecycle&quot;:{
            &quot;name&quot;: &quot;common-logs-policy&quot;
        }
    }
}
</code></pre>
<p>然后一路next，创建完毕。</p>
<p>由于默认的<code>logs-*</code>的匹配优先级是100，我们创建了优先级更高的模板，就自动将形如<code>logs-golang*</code>的索引自动关联到新的索引模板和生命周期策略上了。</p>
<p>另外提一下，golang的panic日志一般不需要采集，直接用<code>File Integrity Monitoring Integration</code>这个集成进行文件监测即可。</p>
<h3 id="配置采集器fleet">配置采集器(Fleet)</h3>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/WRYNswyo1d3qrJV-20230307194343541.png" alt="image-20221026180330634"></p>
<p>在<code>Custom Logs</code>的添加界面上，命名空间配置当前环境(如<code>dev</code>)，点击高级配置，dataset填入服务的名字，如<code>golang_video</code>，这样最后index的名字就是<code>logs-golang_video-dev</code>，由于这里已经指定中划线作为分隔符，所以dataset中不能出现<code>-</code>. 建议这里将同一个格式的日志放在一个配置里（不同命名空间的需要分开），方便修改，可以从log.path里分辨出日志具体属于哪个服务。</p>
<p>通过名称匹配，这个索引会自动关联上文创建的索引模板。pipeline则需要手动关联，在<code>Custom configurations</code>下面，填入如下yaml：</p>
<pre><code class="language-yaml">pipeline: golang-common-log-parser
</code></pre>
<p>日志路径可以添加多个，可以使用通配符。</p>
<h3 id="确认配置">确认配置</h3>
<p>一切正常的话，在Observablity里面正常应该可以看到刚添加的应用日志了，也可以在<code>Discover</code>里面自己过滤查询。</p>
<p>可以用<code>event.dataset</code>搜索上面添加的<code>golang_sip_server</code>，看到对应的日志。</p>
<p>如果没有日志，一般在Fleet的代理日志里可以看到相关信息。或者去所在机器的<code>/opt/Elastic/Agent</code>目录下，查看采集侧的<code>njson</code>日志。</p>
<h2 id="kql简单学习">KQL简单学习</h2>
<p>ES的查询语法是复杂的JSON，直接在界面上不方便使用，所以kibana实际上使用了一种名为KQL的方言（DSL）。其使用较为简单，这里记录一下要点：</p>
<ol>
<li>简单的term匹配，使用<code>k: v</code>的形式，多个v可以用空格隔开，表示<strong>或</strong>关系。如果值中包含空格，使用双引号；</li>
<li>允许使用and, or和not逻辑操作，允许使用括号；注意not是放在k前面的，而不是v前面；</li>
<li>数组匹配多个值，使用and，如<code>tags:(success and info and security)</code>;</li>
<li>范围查询，支持&gt;, &lt;, = 各种组合；</li>
<li>日期查询一般用右侧的time filter，不过也可以手动写 <code>@timestamp &lt; &quot;2022-10-10&quot;</code>之类的，也支持类似influxdb的算术表达式；</li>
<li>允许使用<code>*</code>做模糊匹配，k或者v中都可以；</li>
<li>list of object的匹配，匹配object中的字段，使用大括号。例如<code>items:{name: banana}</code>这种；</li>
<li>如果是多级嵌套，如<code>k1:[{k2: [{&quot;k3&quot;: &quot;v&quot;}]]</code>，搜索的时候需要写全路径，即<code>k1.k2:{k3: v}</code>这种搜索；</li>
</ol>
<h2 id="安装elastic-apm">安装Elastic APM</h2>
<p>这里的APM其实指的是Trace系统，通过Fleet直接绑定集成就可以。</p>
<p>推荐使用OpenTelemetry的Agent进行Export，方便将来迁移到其他平台。</p>
<p>对于Java而言，可以使用自动导出，支持大部分组件。Go/C++服务则需要手动集成，并且需要修改大量代码。</p>
<p>跨服务传递时，一般通过<code>traceparent</code>和<code>tracestate</code>header进行传递，相关w3c标准见<a href="https://w3c.github.io/trace-context/">这里</a>.</p>
<p>sdk提供了propagate相关的API，用来Inject和Extract trace上下文，使用起来非常方便。</p>
<h2 id="周期性任务">周期性任务</h2>
<p>很多指标需要持续计算，比如日活，统计周期内的错误占比等。</p>
<p>在<code>StackManagement</code>-<code>汇总/打包作业</code>里，可以创建定时任务，具体使用请查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rollup-put-job.html">官方文档</a>.</p>
<h2 id="告警配置">告警配置</h2>
<p>下面开始配置告警，告警有很多入口，请根据需要选择：</p>
<ol>
<li>在可观测性(Observability)里，这里可以设置简单的阈值告警；</li>
<li>在Security-告警里，这里可以使用复杂的表达式从ES中进行各种数据查询并创建告警;</li>
<li>在Stack Management-告警和洞见-Watcher里，这里可以直接用json语句创建告警，这是最灵活，同时也是最复杂的方法；</li>
<li>（推荐）还是在告警与洞见这里，在规则和连接器里，这里可以设置所有场景的告警，也包括一般的es查询；</li>
</ol>
<h3 id="连接器">连接器</h3>
<p>告警的发布对象被称为“连接器”，免费提供的只有kibana日志和写入es index，有三个解决方案：</p>
<ol>
<li>可以自己写一个简单的工具监控es/kibana日志并调用钉钉发送告警；</li>
<li>使用<a href="https://elastalert2.readthedocs.io/en/latest/elastalert.html">ElasticAlert2</a>项目；</li>
<li>升级到白金许可证（或者使用<a href="https://github.com/wolfbolin/crack-elasticsearch-by-docker">这个项目</a>）；</li>
</ol>
<p>这里假设你已经获得了白金许可证，下面使用webhook报警即可。</p>
<p>首先在钉钉群里配置一个机器人，点击群设置-<strong>智能群助手</strong>，添加一个webhook机器人，建议打开IP白名单，或者告警关键词。</p>
<p>钉钉创建一个含有access_token的URL，copy下来，在webhook连接器POSt后面paste这个地址，然后添加header<code>Content-Type: application/json</code>，用json格式发送。</p>
<p>点击保存，在测试页面进行报警测试，消息的格式请参考<a href="https://open.dingtalk.com/document/robots/custom-robot-access#title-72m-8ag-pqw">这里</a>，可以用</p>
<pre><code class="language-json">{
    &quot;msgtype&quot;: &quot;text&quot;,
    &quot;text&quot;:{
        &quot;content&quot;: &quot;Hello World&quot;
    }
}
</code></pre>
<p>做个简单测试。</p>
<h3 id="告警规则">告警规则</h3>
<p>在安全里可以安装Elastic预构建的几百个规则，不过不是很建议全部导入，因为大部分都没啥用。可以考虑激活k8s，linux之内tag的规则，如果使用云厂商自带的监控，则一般不必再使用这里的告警功能，相当于重复监测了，而且<strong>有性能损耗</strong>。</p>
<h4 id="observability使用示例">Observability使用示例</h4>
<p>如果只是简单的创建一个error日志告警，可以在Observability点击创建规则，选择日志阈值，然后创建一个如下的规则：</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/chDWbTyCmFlVs2f-20230307194344056.png" alt="image-20221020141946295"></p>
<p>由于我们在上面的数据预处理里面已经将log.level映射出来，所以这里使用这个字段判断一下就行。连接器选择刚才创建的webhook，在Fired和Recovered两种条件下创建两个不同的告警提示即可。</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/lIORdb4Dt6GwngU-20230307194344606.png" alt="image-20221020142216332"></p>
<p>右侧可以看到这里可以使用的变量。可以注意到这里并<strong>没有字段可以拿到日志的详情</strong>，这是因为这里只能做聚合查询，肯定是拿不到具体日志的详情的，不过可以通过group by source.ip之类的方式获取到具体的主机。如果需要直接提示详细的错误，需要用其他方案；</p>
<h4 id="告警与洞见使用示例推荐">告警与洞见使用示例（推荐）</h4>
<p>点击<strong>创建规则</strong>，选择<strong>Elasticsearch查询</strong>，选择KQL查询，创建一个视图<code>logs-golang*</code>作为索引，这样就自动匹配所有golang服务。</p>
<p>如果不想这么粗放的创建告警，也可以用<code>logs-golang_sip_server*</code>，作为匹配，这样就匹配到单个服务的所有日志。所以index的名字很重要，不要随便取。</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/EqnO2xCD1f6Hb8R-20230307194345086.png" alt="image-20221021090656229"></p>
<p>查询条件仍然是日志等级为ERROR（这里是区分大小写的，可以在预处理里统一转换成大写），这里就是过去5分钟出现任意错误日志则触发。这里在body里面可以拿到<code>{{context.hits}}</code>，我们可以通过<a href="http://mustache.github.io/mustache.5.html">mustache</a>这个模板语言对其内容进行解析。</p>
<p>告警模板：</p>
<pre><code>{
    &quot;msgtype&quot;: &quot;markdown&quot;,
    &quot;markdown&quot;:{
        &quot;title&quot;: &quot;Error log found!&quot;,
        &quot;text&quot;:&quot;&quot;&quot;在过去3分钟内发现{{context.value}}条错误日志，摘录如下： 
 {{#context.hits}} 
 **{{_source.log.file.path}}@{{_source.host.hostname}}:** 
 {{_source.@timestamp}}  {{_source.message}} 
 {{/context.hits}} 
 点击[此链接]({{context.link}})查看详情。&quot;&quot;&quot;
    }
}
</code></pre>
<p>这里三个双引号是kibana特有的语法(与json实际上不兼容)，方便写多行字符串。</p>
<p>恢复模板：</p>
<pre><code class="language-json">{
    &quot;msgtype&quot;: &quot;text&quot;,
    &quot;text&quot;:{
        &quot;content&quot;:&quot;logs-golang*已无新增错误日志&quot;
    }
}
</code></pre>
<p>效果如图：</p>
<p><img src="https://csceciti-iot-devfile.oss-cn-shenzhen.aliyuncs.com/docs/iFZBmhLjnrRbNAG-20230307194345363.png" alt="image-20221021112827617"></p>
<h4 id="安全告警使用示例">安全告警使用示例</h4>
<p>这里其实不太建议使用，非安全问题用这里的规则不太符合ES本身的设计，具体使用方法请自己摸索。</p>
<h4 id="watcher使用示例">watcher使用示例</h4>
<p>watcher属于高级用法，需要自己写全量的JSON来拼凑出表达式，而且也<strong>不支持使用已经配置的连接器</strong>，有兴趣可以看<a href="https://blog.csdn.net/qq_42259469/article/details/124720184">这里</a>，官方github给出了大量<a href="https://github.com/elastic/examples/tree/master/Alerting">examples</a>，以供参考。这里不太建议使用，因为用起来很麻烦，也不好调试。</p>
<h3 id="elasticstack自身的告警">ElasticStack自身的告警</h3>
<p>在告警与洞见里，默认就有一些检测ES本身状态的规则，可以修改。默认只是将告警输出到kibana日志。</p>
<p>查看日志级别，如果是Warning以上的，可以加一个钉钉通知：</p>
<pre><code class="language-json">{
    &quot;msgtype&quot;: &quot;markdown&quot;,
    &quot;markdown&quot;:{
        &quot;title&quot;: &quot;ES Cluster Alert&quot;,
        &quot;text&quot;:&quot;{{context.internalShortMessage}}&quot;
    }
}
</code></pre>
<h3 id="基础设施告警">基础设施告警</h3>
<p>点击创建告警，在<code>Metrics</code>中点击库存(这里翻译也不对……)，这里可以对一般指标（cpu、内存等创建告警）。通用告警模板：</p>
<pre><code class="language-json">{
    &quot;msgtype&quot;: &quot;markdown&quot;,
    &quot;markdown&quot;:{
        &quot;title&quot;: &quot;Host CPU Alert&quot;,
        &quot;text&quot;:&quot;{{context.reason}} \n For detail click [here]({{context.viewInAppUrl}})&quot;
    }
}
</code></pre>
<p>其他的指标都在<code>custom metric</code>选项里，如磁盘空间使用，可以用<code>system.filesystem.used.pct</code>. 建议根据自己的需求阅读官方文档中<a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-module-system.html">system</a>和<a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-module-linux.html">linux</a>这两个采集模块的相关字段解释。</p>
<h2 id="看板配置">看板配置</h2>
<p>在<code>kibana</code>的<code>Analytics</code>部分，可以创建各种看板。</p>
<p>Dashboard里面内置了一部分仪表盘，也可以自己使用KQL筛选数据后自行创建，一般内部监控用这个创建可视化就够了。</p>
<p>Canvas部分则可以通过灵活地拖曳完成各种图表的数据、样式配置，可以非常方便地作出各种炫酷的大屏。</p>
<p>由于这部分内容比较符合使用者的直觉，且更偏向于前端的工作，这里就不写详细的配置步骤了。有需求可以阅读<a href="https://www.elastic.co/guide/en/kibana/current/create-a-dashboard-of-panels-with-web-server-data.html">kibana的文档</a>来学习。</p>
<h2 id="附录中间件采集">附录：中间件采集</h2>
<p>大部分中间件都集成在fleet里了，如果不能满足需求，可以点开custom这一栏。已经有官方集成的这里就不写了，包括MySQL、Redis、kafka、rabbitMQ和Nginx。</p>
<h3 id="emqx">emqx</h3>
<p>需要先将数据推送到pushgateway，然后从pushgateway暴露/metrics端口给prometheus或者metricbeat使用。
需要几步：</p>
<ol>
<li>安装pushgateway，<a href="https://github.com/prometheus/pushgateway/releases/tag/v1.4.3">pushgateway下载</a></li>
<li>开启emqx_prometheus插件，可在emqx的dashboard的插件模块下开启</li>
<li>配置/etc/emqx/plugins/emqx_prometheus.conf文件。将prometheus.push.gateway.server配置为对应pushgateway的地址，通常是http://xxx/9091; prometheus.interval使用默认值即可</li>
<li>调用pushgateway的metrics接口即可，通常是http://xxx:9091/metrics</li>
</ol>
<h3 id="influxdb-cluster">influxdb cluster</h3>
<p>支持metrics接口，可以直接用。不过能采集到的数据其实都是默认的golang exporter里面的。</p>
<p>通过<code>debug/vars</code>接口可以拿到influxdb本身的监控数据，不过这个不是prometheus格式的，需要自己转换。</p>
<p>可以通过开源的<a href="https://github.com/prometheus/influxdb_exporter">influxdb exporter</a>或者直接用<a href="https://github.com/influxdata/telegraf">telegraf</a>作为exporter，后者在output里面启动一个prometheus client即可.</p>
<p>telegraf其实可以代替MetricBeat直接将数据发到es，不过和kibana那套体系配合的不是很好，需要自己管理相关index.</p>
<h3 id="seaweedfs">seaweedFS</h3>
<p>参考<a href="https://github.com/seaweedfs/seaweedfs/wiki/System-Metrics">这里</a>，需要启动服务时额外配置metrics端口。</p>
<p>官方给了grafana的json配置，kibana这边就需要自己配置了。</p>
<h3 id="nacos">nacos</h3>
<p>官方支持Metric导出，参考<a href="https://nacos.io/zh-cn/docs/monitor-guide.html">这里</a></p>
<h3 id="阿里云商用中间件">阿里云商用中间件</h3>
<p>可以参考<a href="https://github.com/aylei/aliyun-exporter"><code>aliyun-exporter</code></a>这个repo，虽然已经archive，不过思路没变。</p>
<h2 id="附录1中间件采集">附录1：中间件采集</h2>
<p>大部分中间件都集成在fleet里了，如果不能满足需求，可以点开custom这一栏。已经有官方集成的这里就不写了，包括MySQL、Redis、kafka、rabbitMQ和Nginx。</p>
<h3 id="emqx-1">emqx</h3>
<p>需要先将数据推送到pushgateway，然后从pushgateway暴露/metrics端口给prometheus或者metricbeat使用。
需要几步：</p>
<ol>
<li>安装pushgateway，<a href="https://github.com/prometheus/pushgateway/releases/tag/v1.4.3">pushgateway下载</a></li>
<li>开启emqx_prometheus插件，可在emqx的dashboard的插件模块下开启</li>
<li>配置/etc/emqx/plugins/emqx_prometheus.conf文件。将prometheus.push.gateway.server配置为对应pushgateway的地址，通常是http://xxx/9091; prometheus.interval使用默认值即可</li>
<li>调用pushgateway的metrics接口即可，通常是http://xxx:9091/metrics</li>
</ol>
<h3 id="influxdb-cluster-1">influxdb cluster</h3>
<p>支持metrics接口，可以直接用。不过能采集到的数据其实都是默认的golang exporter里面的。</p>
<p>通过<code>debug/vars</code>接口可以拿到influxdb本身的监控数据，不过这个不是prometheus格式的，需要自己转换。</p>
<p>可以通过开源的<a href="https://github.com/prometheus/influxdb_exporter">influxdb exporter</a>或者直接用<a href="https://github.com/influxdata/telegraf">telegraf</a>作为exporter，后者在output里面启动一个prometheus client即可.</p>
<p>telegraf其实可以代替MetricBeat直接将数据发到es，不过和kibana那套体系配合的不是很好，需要自己管理相关index.</p>
<h3 id="seaweedfs-1">seaweedFS</h3>
<p>参考<a href="https://github.com/seaweedfs/seaweedfs/wiki/System-Metrics">这里</a>，需要启动服务时额外配置metrics端口。</p>
<p>官方给了grafana的json配置，kibana这边就需要自己配置了。</p>
<h3 id="nacos-1">nacos</h3>
<p>官方支持Metric导出，参考<a href="https://nacos.io/zh-cn/docs/monitor-guide.html">这里</a></p>
<h3 id="阿里云商用中间件-1">阿里云商用中间件</h3>
<p>可以参考<a href="https://github.com/aylei/aliyun-exporter"><code>aliyun-exporter</code></a>这个repo，虽然已经archive，不过思路没变。</p>
<h2 id="附录2es常见问题">附录2：ES常见问题</h2>
<h3 id="磁盘空间不足">磁盘空间不足</h3>
<p>到<code>Stack Management</code>-<code>索引管理</code>里，打开<code>包括隐藏的索引</code>，点击<code>存储大小</code>，使其从大到小排序。</p>
<p>点击索引名称，右侧会显示“索引生命周期管理”，查看对应的生命周期策略是否需要调整。如果是托管的策略，不建议直接修改，改为修改索引/数据流对应的模板，在模板中添加生命周期策略即可。</p>
<p>可以视具体情况删除部分索引。</p>
<h3 id="索引无法删除提示bad-request">索引无法删除，提示bad request</h3>
<p>这种一般是由于索引正在被使用，必须先解除使用。</p>
<p>点击索引名称，点击“编辑设置”。</p>
<p>先看索引是否设置了<code>index.lifecycle.indexing_complete=true</code>，有的话改为<code>false</code>，这个选项会导致索引skip rollover，一直往同一个索引里面写。</p>
<p>然后为索引正常设置生命周期策略（如：<code>&quot;index.lifecycle.name&quot;: &quot;metricbeat&quot;</code>），并确认有个别名：<code>index.lifecycle.rollover_alias</code>，别名可以随意。</p>
<p>最后需要手动滚动数据流，到控制台上运行：</p>
<pre><code class="language-bash">POST &lt;datastream/alias name&gt;/_rollover
</code></pre>
<p>正常的话，会创建一个新的索引。这样就可以删掉原来的索引了。</p>

        </div>
        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">上一页</span>
        <a href="https://yiuterran.github.io/blog/posts/%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/" class="block">监控平台调研报告</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">下一页</span>
        <a href="https://yiuterran.github.io/blog/posts/sre%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="block">SRE读书笔记</a>
        
    </div>
</div>

        



  <script id="utterances" src="https://utteranc.es/client.js"
            issue-term=title
            repo=YiuTerran/blog-comment
              theme=preferred-color-scheme
        crossorigin="anonymous"
        async>
</script>
<script>
    if (storageColorScheme == "Light") {
      document.getElementById('utterances').setAttribute('theme', 'github-light')
    } else if (storageColorScheme == "Dark") {
      document.getElementById('utterances').setAttribute('theme', 'github-dark')
    }
</script>

    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">本页内容</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#elasticsearch部分">ElasticSearch部分</a>
      <ul>
        <li><a href="#安装es">安装ES</a></li>
        <li><a href="#配置es">配置ES</a></li>
        <li><a href="#集群管理">集群管理</a></li>
      </ul>
    </li>
    <li><a href="#kibana部分">Kibana部分</a>
      <ul>
        <li><a href="#安装kibana">安装kibana</a></li>
        <li><a href="#配置kibana">配置kibana</a></li>
      </ul>
    </li>
    <li><a href="#安装fleet-server">安装Fleet Server</a></li>
    <li><a href="#安装elastic-agent">安装Elastic Agent</a></li>
    <li><a href="#安装metricbeatecs可选">安装Metricbeat(ECS/可选)</a>
      <ul>
        <li><a href="#基础配置">基础配置</a></li>
        <li><a href="#采集es信息">采集ES信息</a></li>
        <li><a href="#启动服务">启动服务</a></li>
      </ul>
    </li>
    <li><a href="#安装metricbeatk8s">安装Metricbeat(k8s)</a>
      <ul>
        <li><a href="#基础配置-1">基础配置</a></li>
        <li><a href="#服务监控配置">服务监控配置</a></li>
        <li><a href="#部署">部署</a></li>
      </ul>
    </li>
    <li><a href="#安装filebeat">安装Filebeat</a></li>
    <li><a href="#数据生命周期管理ilm">数据生命周期管理(ILM)</a></li>
    <li><a href="#prometheus-metrics采集fleet">Prometheus Metrics采集(Fleet)</a></li>
    <li><a href="#uptime监控">Uptime监控</a></li>
    <li><a href="#应用日志采集">应用日志采集</a>
      <ul>
        <li><a href="#数据预处理">数据预处理</a></li>
        <li><a href="#配置索引模板">配置索引模板</a></li>
        <li><a href="#配置采集器fleet">配置采集器(Fleet)</a></li>
        <li><a href="#确认配置">确认配置</a></li>
      </ul>
    </li>
    <li><a href="#kql简单学习">KQL简单学习</a></li>
    <li><a href="#安装elastic-apm">安装Elastic APM</a></li>
    <li><a href="#周期性任务">周期性任务</a></li>
    <li><a href="#告警配置">告警配置</a>
      <ul>
        <li><a href="#连接器">连接器</a></li>
        <li><a href="#告警规则">告警规则</a>
          <ul>
            <li><a href="#observability使用示例">Observability使用示例</a></li>
            <li><a href="#告警与洞见使用示例推荐">告警与洞见使用示例（推荐）</a></li>
            <li><a href="#安全告警使用示例">安全告警使用示例</a></li>
            <li><a href="#watcher使用示例">watcher使用示例</a></li>
          </ul>
        </li>
        <li><a href="#elasticstack自身的告警">ElasticStack自身的告警</a></li>
        <li><a href="#基础设施告警">基础设施告警</a></li>
      </ul>
    </li>
    <li><a href="#看板配置">看板配置</a></li>
    <li><a href="#附录中间件采集">附录：中间件采集</a>
      <ul>
        <li><a href="#emqx">emqx</a></li>
        <li><a href="#influxdb-cluster">influxdb cluster</a></li>
        <li><a href="#seaweedfs">seaweedFS</a></li>
        <li><a href="#nacos">nacos</a></li>
        <li><a href="#阿里云商用中间件">阿里云商用中间件</a></li>
      </ul>
    </li>
    <li><a href="#附录1中间件采集">附录1：中间件采集</a>
      <ul>
        <li><a href="#emqx-1">emqx</a></li>
        <li><a href="#influxdb-cluster-1">influxdb cluster</a></li>
        <li><a href="#seaweedfs-1">seaweedFS</a></li>
        <li><a href="#nacos-1">nacos</a></li>
        <li><a href="#阿里云商用中间件-1">阿里云商用中间件</a></li>
      </ul>
    </li>
    <li><a href="#附录2es常见问题">附录2：ES常见问题</a>
      <ul>
        <li><a href="#磁盘空间不足">磁盘空间不足</a></li>
        <li><a href="#索引无法删除提示bad-request">索引无法删除，提示bad request</a></li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="ps-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://github.com/YiuTerran">tryao</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>